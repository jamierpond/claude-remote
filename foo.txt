### Repo tree:
.
â”œâ”€â”€ AGENTS.md
â”œâ”€â”€ CLAUDE.md
â”œâ”€â”€ claude-remote.service
â”œâ”€â”€ client
â”‚Â Â  â””â”€â”€ src
â”‚Â Â      â”œâ”€â”€ App.tsx
â”‚Â Â      â”œâ”€â”€ components
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ ChatInput.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ GitStatus.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ ProjectPicker.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ ProjectTabs.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ StreamingResponse.tsx
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ ToolStack.tsx
â”‚Â Â      â”‚Â Â  â””â”€â”€ types.ts
â”‚Â Â      â”œâ”€â”€ index.css
â”‚Â Â      â”œâ”€â”€ main.tsx
â”‚Â Â      â””â”€â”€ pages
â”‚Â Â          â”œâ”€â”€ Chat.tsx
â”‚Â Â          â””â”€â”€ Home.tsx
â”œâ”€â”€ eslint.config.mjs
â”œâ”€â”€ .gitignore
â”œâ”€â”€ index.html
â”œâ”€â”€ issues
â”‚Â Â  â””â”€â”€ scroll-jump-during-typing.md
â”œâ”€â”€ package.json
â”œâ”€â”€ PLAN-MULTI-PROJECT.md
â”œâ”€â”€ pnpm-lock.yaml
â”œâ”€â”€ pnpm-workspace.yaml
â”œâ”€â”€ public
â”‚Â Â  â”œâ”€â”€ file.svg
â”‚Â Â  â”œâ”€â”€ globe.svg
â”‚Â Â  â”œâ”€â”€ next.svg
â”‚Â Â  â”œâ”€â”€ vercel.svg
â”‚Â Â  â””â”€â”€ window.svg
â”œâ”€â”€ README.md
â”œâ”€â”€ server.ts
â”œâ”€â”€ src
â”‚Â Â  â”œâ”€â”€ lib
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ claude.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ crypto.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ store.ts
â”‚Â Â  â””â”€â”€ types
â”‚Â Â      â””â”€â”€ qrcode-terminal.d.ts
â”œâ”€â”€ tsconfig.json
â””â”€â”€ vite.config.ts

10 directories, 36 files


### Skipping binary: AGENTS.md



#########################
### CLAUDE.md
# Claude Remote Implementation Plan

## Development Principles

### Error Handling: SEEK ERRORS, DON'T HIDE THEM
- **Always show errors to the user** - silent failures waste hours of debugging
- When implementing any flow (pairing, auth, network calls, crypto):
  1. Wrap each step in try-catch
  2. Log with `debugPrint('[CONTEXT] Step N: description...')`
  3. On failure, throw with context: `throw Exception('Step N failed: $e')`
  4. Surface errors in the UI immediately - red box, full error text, selectable
- **Never assume success** - if something can fail, show what happened
- **Verbose by default** - it's easier to remove logs than to add them when debugging

### URL Mapping (Production)
- `ai.pond.audio` = web client (served static files)
- `ai-server.pond.audio` = API server (WebSocket, REST)
- Flutter client must map client URLs to server URLs for API calls

### After Code Changes: ALWAYS VERIFY
- After making Flutter/Dart changes, run `flutter analyze` to check for errors
- Run `flutter build web` to verify it compiles
- Use `make reload` to hot-reload connected clients
- Don't assume changes work - verify they build before moving on

### UI: NO PLACEHOLDER/INOP ELEMENTS
- Never add UI elements (buttons, icons, etc.) that don't work yet
- No "TODO: implement" buttons - either implement it fully or don't add it
- Confusing inop UI is worse than no UI

## Overview
Mobile chat interface for local Claude CLI with E2E encryption. Personal use - access Claude from phone via Cloudflare tunnel.

## Architecture

### Tech Stack
- **Next.js 16** with App Router
- **Custom server** for WebSocket support
- **Tailwind CSS** for styling
- **argon2** for PIN hashing
- **qrcode** for QR generation
- **ws** for WebSocket server

### Directory Structure
```
claude-remote/
â”œâ”€â”€ server.ts              # Custom server with WebSocket
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ crypto.ts      # ECDH + AES-GCM encryption
â”‚   â”‚   â”œâ”€â”€ store.ts       # Config/device persistence
â”‚   â”‚   â””â”€â”€ claude.ts      # Claude CLI spawning
â”‚   â””â”€â”€ app/
â”‚       â”œâ”€â”€ page.tsx       # QR code / paired status
â”‚       â”œâ”€â”€ pair/[token]/
â”‚       â”‚   â””â”€â”€ route.ts   # Pairing API endpoints
â”‚       â””â”€â”€ chat/
â”‚           â””â”€â”€ page.tsx   # Chat interface
```

## Files to Create

### 1. `src/lib/crypto.ts`
- `generateKeyPair()` - ECDH P-256
- `deriveSharedSecret(privateKey, peerPublicKey)` - ECDH derive
- `encrypt(plaintext, secret)` - AES-256-GCM, returns {iv, ct, tag}
- `decrypt(encrypted, secret)` - AES-256-GCM
- Key serialization helpers (base64 <-> Buffer)

### 2. `src/lib/store.ts`
- Config dir: `~/.config/claude-remote/`
- `loadDevice()` / `saveDevice()` - device.json
- `loadConfig()` / `saveConfig()` - config.json (PIN hash)
- `hashPin(pin)` / `verifyPin(pin, hash)` - argon2

### 3. `src/lib/claude.ts`
- `spawnClaude(message, onEvent, signal)` - spawn CLI with streaming
- Parse JSON stream events: content_block_start, content_block_delta
- Map to simplified events: {type: 'thinking'|'text', text, done}
- Handle cancel via AbortSignal

### 4. `server.ts`
- Custom Next.js server on port 3001
- WebSocket server on `/ws`:
  - Verify device is paired
  - Handle encrypted messages: auth, message, cancel
  - Stream encrypted responses back
- Session management: authenticated state per connection

### 5. `src/app/page.tsx`
- Server component showing QR code when no device paired
- Shows "Paired" status when device exists
- QR contains URL: `{baseUrl}/pair/{token}`

### 6. `src/app/pair/[token]/route.ts`
- `GET` - Return server public key
- `POST` - Receive client public key, complete pairing

### 7. `src/app/chat/page.tsx`
Client-side chat interface:
- **Crypto**: Web Crypto API for ECDH + AES-GCM
- **Views**: PIN entry â†’ Chat
- **Chat UI**: Thinking bubbles, response bubbles, input
- **WebSocket**: Connect, encrypt/decrypt messages
- **Storage**: localStorage for deviceId, privateKey, sharedSecret

## Pairing Flow

1. Server generates ECDH keypair + random token on startup (if no device)
2. Desktop shows QR code with URL: `{baseUrl}/pair/{token}`
3. Phone scans, opens URL, generates own ECDH keypair
4. Phone POSTs its public key to `/pair/{token}`
5. Server derives shared secret, stores device, returns its public key
6. Phone derives shared secret, stores locally
7. Server now shows "paired" status, phone redirects to chat

## Message Flow

1. Phone connects WebSocket, sends encrypted `{type: 'auth', pin}`
2. Server decrypts, verifies PIN hash, sends encrypted `{type: 'auth_ok'}`
3. Phone sends encrypted `{type: 'message', text}`
4. Server spawns `claude --print --output-format stream-json`
5. Server streams encrypted `{type: 'thinking'|'text', text, done}` events
6. Phone decrypts and displays in real-time

## Dev Logging

All dev commands tee output to log files in `logs/`:

- `pnpm dev` â†’ `logs/server.log` + `logs/client.log`
- `pnpm dev:server` â†’ `logs/server.log`
- `pnpm dev:client` â†’ `logs/client.log`
- `pnpm start` â†’ `logs/server.log`

Tail logs with:
- `pnpm logs:server`
- `pnpm logs:client`

The `logs/` directory is gitignored.

## Verification

1. `npm run dev` - starts server on port 3001
2. Open localhost:3001 - see QR code
3. Scan QR with phone, complete pairing
4. Set PIN, verify PIN entry works
5. Send message, verify streaming response
6. Test cancel functionality



#########################
### README.md
# Claude Remote

A secure mobile-friendly web interface for remotely accessing Claude Code from your phone or any device.

## Features

- **End-to-end encryption** - ECDH key exchange + AES-GCM encryption
- **QR code pairing** - Easy device pairing with QR codes
- **PIN protection** - Secure access with a PIN
- **Mobile-first UI** - Optimized for phones with touch-friendly controls
- **Real-time streaming** - See Claude's responses as they're generated
- **Rich activity panel** - See exactly what Claude is doing:
  - Tool calls with icons (Read, Write, Edit, Bash, etc.)
  - **Live diff view** for file edits (red for removed, green for added)
  - Syntax-highlighted bash commands
  - Collapsible tool results
  - Live streaming indicator

## Activity Panel

The chat interface includes a collapsible Activity panel that shows Claude's tool usage in real-time:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â–¶ Activity                    ğŸ“„ Read  ğŸ”§ Edit  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â–¶ ğŸ“„ Read                     Chat.tsx          â”‚
â”‚ â–¶ ğŸ”§ Edit                     Chat.tsx          â”‚
â”‚   â”œâ”€ /client/src/pages/Chat.tsx                 â”‚
â”‚   â”œâ”€ - Remove:                                  â”‚
â”‚   â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚   â”‚ const [foo, setFoo] = useState('');  â”‚  â”‚
â”‚   â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚   â””â”€ + Add:                                     â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚       â”‚ const [bar, setBar] = useState('');  â”‚  â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚ â–¶ ğŸ’» Bash                     pnpm run dev...   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Tool Icons

| Icon | Tool | Description |
|------|------|-------------|
| ğŸ“„ | Read | Reading files |
| âœï¸ | Write | Creating new files |
| ğŸ”§ | Edit | Modifying existing files (shows diff) |
| ğŸ’» | Bash | Running shell commands |
| ğŸ” | Glob | Finding files by pattern |
| ğŸ” | Grep | Searching file contents |
| ğŸ¤– | Task | Spawning sub-agents |
| ğŸŒ | WebFetch | Fetching web content |
| ğŸ“ | TodoWrite | Managing task lists |
| â“ | AskUserQuestion | Asking for input |

## Getting Started

### Prerequisites

- Node.js 20+
- pnpm
- Claude CLI installed and authenticated

### Installation

```bash
pnpm install
```

### Development

```bash
pnpm run dev
```

This starts both the server (port 6767) and Vite dev server (port 5173).

### Environment Variables

Create a `.env.local` file:

```bash
PIN=1234              # Access PIN
CLIENT_URL=https://your-domain.com
SERVER_URL=https://your-server.com
```

## Architecture

- **Frontend**: React + TypeScript + Tailwind CSS (Vite)
- **Backend**: Node.js WebSocket server
- **Security**: ECDH key exchange, AES-256-GCM encryption
- **Claude Integration**: Spawns Claude CLI with `--output-format stream-json`

## Mobile Optimizations

- Dynamic viewport height (`100dvh`) for proper mobile browser support
- Safe area insets for notched devices
- 44px minimum touch targets
- Rounded pill-style input and buttons
- Collapsible sections to maximize screen space

## License

MIT



#########################
### claude-remote.service
[Unit]
Description=Claude Remote Server
After=network.target

[Service]
Type=simple
WorkingDirectory=/home/jamie/projects/remote-claude-real
ExecStart=/home/jamie/.nix-profile/bin/pnpm tsx server.ts
Environment=NODE_ENV=production
Environment=PATH=/home/jamie/.local/bin:/home/jamie/.nix-profile/bin:/usr/local/bin:/usr/bin:/bin
Restart=always
RestartSec=3

# Logging to file
StandardOutput=append:/home/jamie/projects/remote-claude-real/logs/daemon-server.log
StandardError=append:/home/jamie/projects/remote-claude-real/logs/daemon-server.log

[Install]
WantedBy=default.target



#########################
### client/src/App.tsx
import { useState, useEffect } from 'react';
import Home from './pages/Home';
import Chat from './pages/Chat';

type Route = 'home' | 'chat' | 'pair';

export default function App() {
  const [route, setRoute] = useState<Route>('home');
  const [pairToken, setPairToken] = useState<string | null>(null);

  useEffect(() => {
    const path = window.location.pathname;
    const params = new URLSearchParams(window.location.search);

    if (path.startsWith('/pair/')) {
      const token = path.split('/pair/')[1];
      setPairToken(token);
      setRoute('pair');
    } else if (path === '/chat' || params.get('token')) {
      setPairToken(params.get('token'));
      setRoute('chat');
    } else {
      setRoute('home');
    }
  }, []);

  const navigate = (newRoute: Route) => {
    if (newRoute === 'home') {
      window.history.pushState({}, '', '/');
    } else if (newRoute === 'chat') {
      window.history.pushState({}, '', '/chat');
    }
    setRoute(newRoute);
  };

  if (route === 'home') {
    return <Home onNavigate={navigate} />;
  }

  return <Chat token={pairToken} onNavigate={navigate} />;
}



#########################
### client/src/components/ChatInput.tsx
import { useState, useRef, useCallback, memo } from 'react';

interface ChatInputProps {
  isStreaming: boolean;
  onSend: (text: string) => void;
  onCancel: () => void;
}

export default memo(function ChatInput({ isStreaming, onSend, onCancel }: ChatInputProps) {
  const [input, setInputRaw] = useState(() => localStorage.getItem('claude-remote-draft') || '');
  const draftTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const setInput = useCallback((v: string) => {
    setInputRaw(v);
    if (draftTimerRef.current) clearTimeout(draftTimerRef.current);
    draftTimerRef.current = setTimeout(() => {
      if (v) localStorage.setItem('claude-remote-draft', v);
      else localStorage.removeItem('claude-remote-draft');
    }, 500);
  }, []);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim() || isStreaming) return;
    const text = input.trim();
    setInput('');
    onSend(text);
  };

  return (
    <form onSubmit={handleSubmit} className="flex gap-2 items-end">
      <input
        type="text"
        value={input}
        onChange={(e) => setInput(e.target.value)}
        placeholder={isStreaming ? "Task running..." : "New task..."}
        className="flex-1 min-h-[44px] px-4 py-3 bg-[var(--color-bg-secondary)] rounded-full focus:outline-none focus:ring-2 focus:ring-[var(--color-accent)] text-base"
      />
      {isStreaming ? (
        <button
          type="button"
          onClick={onCancel}
          className="min-w-[44px] min-h-[44px] flex items-center justify-center bg-red-600 rounded-full font-semibold hover:bg-red-700 active:bg-red-800 transition-colors"
          aria-label="Cancel"
        >
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8 7a1 1 0 00-1 1v4a1 1 0 001 1h4a1 1 0 001-1V8a1 1 0 00-1-1H8z" clipRule="evenodd" />
          </svg>
        </button>
      ) : (
        <button
          type="submit"
          disabled={!input.trim()}
          className="min-w-[44px] min-h-[44px] flex items-center justify-center bg-[var(--color-accent)] rounded-full font-semibold hover:bg-[var(--color-accent-hover)] active:bg-[#a04e30] transition-colors disabled:opacity-50 disabled:hover:bg-[var(--color-accent)]"
          aria-label="Send"
        >
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
            <path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" />
          </svg>
        </button>
      )}
    </form>
  );
})



#########################
### client/src/components/GitStatus.tsx
import { useState, useEffect, useCallback } from 'react';
import { apiFetch } from '../lib/api';

interface GitFile {
  status: string;
  path: string;
}

interface GitStatusData {
  branch: string;
  isDirty: boolean;
  changedFiles: number;
  files: GitFile[];
  ahead: number;
  behind: number;
}

// Git status code to color/label
function fileStatusColor(status: string): string {
  if (status.includes('M')) return 'text-yellow-300';
  if (status.includes('A')) return 'text-green-300';
  if (status.includes('D')) return 'text-red-300';
  if (status.includes('R')) return 'text-blue-300';
  if (status === '??') return 'text-[var(--color-text-tertiary)]';
  return 'text-[var(--color-text-secondary)]';
}

function fileStatusLabel(status: string): string {
  if (status === '??') return 'new';
  if (status.includes('M')) return 'mod';
  if (status.includes('A')) return 'add';
  if (status.includes('D')) return 'del';
  if (status.includes('R')) return 'ren';
  return status;
}

interface GitStatusProps {
  projectId: string | null;
}

export default function GitStatus({ projectId }: GitStatusProps) {
  const [status, setStatus] = useState<GitStatusData | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [expanded, setExpanded] = useState(false);

  const fetchStatus = useCallback(async () => {
    if (!projectId) {
      console.log('[GitStatus] No projectId, skipping fetch');
      setStatus(null);
      return;
    }

    console.log('[GitStatus] Fetching git status for:', projectId);
    setLoading(true);
    try {
      const res = await apiFetch(`/api/projects/${encodeURIComponent(projectId)}/git`);
      if (!res.ok) {
        const data = await res.json();
        console.error('[GitStatus] API error:', data);
        throw new Error(data.error || 'Failed to fetch git status');
      }
      const data = await res.json();
      console.log('[GitStatus] Got status:', data);
      setStatus(data);
      setError(null);
    } catch (err) {
      console.error('[GitStatus] Fetch failed:', err);
      setError(err instanceof Error ? err.message : 'Unknown error');
      setStatus(null);
    } finally {
      setLoading(false);
    }
  }, [projectId]);

  // Fetch on mount and when projectId changes
  useEffect(() => {
    fetchStatus();
  }, [fetchStatus]);

  // Refresh periodically (every 30s)
  useEffect(() => {
    if (!projectId) return;
    const interval = setInterval(fetchStatus, 30000);
    return () => clearInterval(interval);
  }, [projectId, fetchStatus]);

  if (!projectId || error) {
    return null;
  }

  if (loading && !status) {
    return (
      <div className="flex items-center gap-1.5 px-2 py-1 bg-[var(--color-bg-secondary)] rounded-lg">
        <div className="w-3 h-3 border border-[var(--color-text-tertiary)] border-t-transparent rounded-full animate-spin" />
      </div>
    );
  }

  if (!status) {
    return null;
  }

  return (
    <div className="relative">
      <button
        onClick={() => setExpanded(!expanded)}
        className={`
          flex items-center gap-1.5 px-2 py-1 rounded-lg text-xs font-medium transition-colors
          ${status.isDirty
            ? 'bg-yellow-900/50 text-yellow-300 hover:bg-yellow-900/70'
            : 'bg-[var(--color-bg-secondary)] text-[var(--color-text-secondary)] hover:bg-[var(--color-bg-hover)]'
          }
        `}
        title={`${status.branch}${status.isDirty ? ' (uncommitted changes)' : ''}`}
      >
        {/* Git branch icon */}
        <svg className="w-3.5 h-3.5" viewBox="0 0 16 16" fill="currentColor">
          <path fillRule="evenodd" d="M11.75 2.5a.75.75 0 100 1.5.75.75 0 000-1.5zm-2.25.75a2.25 2.25 0 113 2.122V6A2.5 2.5 0 0110 8.5H6a1 1 0 00-1 1v1.128a2.251 2.251 0 11-1.5 0V5.372a2.25 2.25 0 111.5 0v1.836A2.492 2.492 0 016 7h4a1 1 0 001-1v-.628A2.25 2.25 0 019.5 3.25zM4.25 12a.75.75 0 100 1.5.75.75 0 000-1.5zM3.5 3.25a.75.75 0 111.5 0 .75.75 0 01-1.5 0z" />
        </svg>

        <span className="truncate max-w-[100px]">{status.branch}</span>

        {/* Dirty indicator */}
        {status.isDirty && (
          <span className="w-1.5 h-1.5 bg-yellow-400 rounded-full" />
        )}

        {/* Ahead/behind indicators */}
        {status.ahead > 0 && (
          <span className="text-green-400" title={`${status.ahead} commits ahead`}>
            â†‘{status.ahead}
          </span>
        )}
        {status.behind > 0 && (
          <span className="text-red-400" title={`${status.behind} commits behind`}>
            â†“{status.behind}
          </span>
        )}
      </button>

      {/* Expanded details dropdown */}
      {expanded && (
        <>
          {/* Backdrop to close */}
          <div
            className="fixed inset-0 z-40"
            onClick={() => setExpanded(false)}
          />

          <div className="absolute top-full right-0 mt-1 z-50 w-56 bg-[var(--color-bg-secondary)] border border-[var(--color-border-default)] rounded-lg shadow-xl overflow-hidden">
            <div className="p-3 space-y-2">
              {/* Branch */}
              <div className="flex items-center gap-2">
                <svg className="w-4 h-4 text-[var(--color-text-tertiary)]" viewBox="0 0 16 16" fill="currentColor">
                  <path fillRule="evenodd" d="M11.75 2.5a.75.75 0 100 1.5.75.75 0 000-1.5zm-2.25.75a2.25 2.25 0 113 2.122V6A2.5 2.5 0 0110 8.5H6a1 1 0 00-1 1v1.128a2.251 2.251 0 11-1.5 0V5.372a2.25 2.25 0 111.5 0v1.836A2.492 2.492 0 016 7h4a1 1 0 001-1v-.628A2.25 2.25 0 019.5 3.25zM4.25 12a.75.75 0 100 1.5.75.75 0 000-1.5zM3.5 3.25a.75.75 0 111.5 0 .75.75 0 01-1.5 0z" />
                </svg>
                <span className="text-sm text-[var(--color-text-primary)] font-medium">{status.branch}</span>
              </div>

              {/* Status summary */}
              {status.isDirty ? (
                <div className="flex items-center gap-2">
                  <div className="w-4 h-4 flex items-center justify-center">
                    <span className="w-2 h-2 bg-yellow-400 rounded-full" />
                  </div>
                  <span className="text-sm text-yellow-300">
                    {status.changedFiles} file{status.changedFiles !== 1 ? 's' : ''} changed
                  </span>
                </div>
              ) : (
                <div className="flex items-center gap-2">
                  <svg className="w-4 h-4 text-green-400" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                  </svg>
                  <span className="text-sm text-green-300">Clean working tree</span>
                </div>
              )}

              {/* Ahead/behind */}
              {(status.ahead > 0 || status.behind > 0) && (
                <div className="flex items-center gap-3 text-sm">
                  {status.ahead > 0 && (
                    <span className="text-green-400">
                      â†‘ {status.ahead} ahead
                    </span>
                  )}
                  {status.behind > 0 && (
                    <span className="text-red-400">
                      â†“ {status.behind} behind
                    </span>
                  )}
                </div>
              )}
            </div>

            {/* Changed files list */}
            {status.files && status.files.length > 0 && (
              <div className="border-t border-[var(--color-border-default)] max-h-48 overflow-y-auto">
                {status.files.map((file, i) => (
                  <div key={i} className="flex items-center gap-2 px-3 py-1.5 text-xs font-mono hover:bg-[var(--color-bg-hover)]">
                    <span className={`shrink-0 w-7 text-right ${fileStatusColor(file.status)}`}>
                      {fileStatusLabel(file.status)}
                    </span>
                    <span className="text-[var(--color-text-secondary)] truncate" title={file.path}>
                      {file.path}
                    </span>
                  </div>
                ))}
              </div>
            )}

            {/* Refresh button */}
            <div className="border-t border-[var(--color-border-default)] p-2">
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  fetchStatus();
                }}
                className="w-full flex items-center justify-center gap-2 px-3 py-1.5 text-xs text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-hover)] rounded transition-colors"
              >
                <svg className={`w-3.5 h-3.5 ${loading ? 'animate-spin' : ''}`} viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clipRule="evenodd" />
                </svg>
                Refresh
              </button>
            </div>
          </div>
        </>
      )}
    </div>
  );
}



#########################
### client/src/components/ProjectPicker.tsx
import { useState, useEffect } from 'react';
import type { Project } from './ProjectTabs';
import { apiFetch } from '../lib/api';

interface ProjectPickerProps {
  isOpen: boolean;
  onClose: () => void;
  onSelect: (project: Project) => void;
  openProjectIds: Set<string>;
}

export default function ProjectPicker({
  isOpen,
  onClose,
  onSelect,
  openProjectIds,
}: ProjectPickerProps) {
  const [projects, setProjects] = useState<Project[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [search, setSearch] = useState('');

  useEffect(() => {
    if (isOpen) {
      fetchProjects();
    }
  }, [isOpen]);

  const fetchProjects = async () => {
    setLoading(true);
    setError(null);
    try {
      const res = await apiFetch('/api/projects');
      if (!res.ok) throw new Error('Failed to fetch projects');
      const data = await res.json();
      setProjects(data.projects || []);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load projects');
    } finally {
      setLoading(false);
    }
  };

  if (!isOpen) return null;

  const filteredProjects = projects.filter(
    (p) =>
      p.name.toLowerCase().includes(search.toLowerCase()) ||
      p.id.toLowerCase().includes(search.toLowerCase())
  );

  return (
    <div className="fixed inset-0 z-50 flex items-end sm:items-center justify-center">
      {/* Backdrop */}
      <div
        className="absolute inset-0 bg-black/60 backdrop-blur-sm"
        onClick={onClose}
      />

      {/* Modal */}
      <div className="relative w-full sm:max-w-md bg-[var(--color-bg-secondary)] rounded-t-2xl sm:rounded-2xl shadow-xl max-h-[80vh] flex flex-col">
        {/* Header */}
        <div className="flex items-center justify-between p-4 border-b border-[var(--color-border-default)]">
          <h2 className="text-lg font-semibold text-[var(--color-text-primary)]">Open Project</h2>
          <button
            onClick={onClose}
            className="p-1 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors"
            aria-label="Close"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
            </svg>
          </button>
        </div>

        {/* Search */}
        <div className="p-3 border-b border-[var(--color-border-default)]">
          <input
            type="text"
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            placeholder="Search projects..."
            className="w-full px-4 py-2 bg-[var(--color-bg-primary)] border border-[var(--color-border-default)] rounded-lg text-[var(--color-text-primary)] placeholder-[var(--color-text-tertiary)] focus:outline-none focus:ring-2 focus:ring-[var(--color-accent)]"
          />
        </div>

        {/* Project list */}
        <div className="flex-1 overflow-y-auto p-2">
          {loading ? (
            <div className="flex items-center justify-center py-8">
              <div className="w-6 h-6 border-2 border-[var(--color-accent)] border-t-transparent rounded-full animate-spin" />
            </div>
          ) : error ? (
            <div className="text-center py-8 text-red-400">
              <p>{error}</p>
              <button
                onClick={fetchProjects}
                className="mt-2 text-sm text-[var(--color-accent)] hover:text-[#d97a5a]"
              >
                Retry
              </button>
            </div>
          ) : filteredProjects.length === 0 ? (
            <div className="text-center py-8 text-[var(--color-text-tertiary)]">
              {search ? 'No matching projects' : 'No projects found in ~/projects'}
            </div>
          ) : (
            <div className="space-y-1">
              {filteredProjects.map((project) => {
                const isOpen = openProjectIds.has(project.id);
                return (
                  <button
                    key={project.id}
                    onClick={() => {
                      onSelect(project);
                      onClose();
                    }}
                    className={`
                      w-full flex items-center gap-3 p-3 rounded-lg text-left transition-colors
                      ${isOpen
                        ? 'bg-[var(--color-accent-muted)] text-[var(--color-accent)]'
                        : 'hover:bg-[var(--color-bg-hover)] text-[var(--color-text-primary)]'
                      }
                    `}
                  >
                    {/* Folder icon */}
                    <div className={`p-2 rounded-lg ${isOpen ? 'bg-[var(--color-accent-muted)]' : 'bg-[var(--color-bg-hover)]'}`}>
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" />
                      </svg>
                    </div>

                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2">
                        <span className="font-medium truncate">{project.name}</span>
                        {isOpen && (
                          <span className="text-xs bg-[var(--color-accent)] px-1.5 py-0.5 rounded">Open</span>
                        )}
                      </div>
                      <div className="text-xs text-[var(--color-text-tertiary)] truncate">
                        {project.path}
                      </div>
                      {project.lastAccessed && (
                        <div className="text-xs text-[var(--color-text-muted)]">
                          Last used: {new Date(project.lastAccessed).toLocaleDateString()}
                        </div>
                      )}
                    </div>

                    {/* Arrow */}
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-[var(--color-text-tertiary)]" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
                    </svg>
                  </button>
                );
              })}
            </div>
          )}
        </div>

        {/* Footer hint */}
        <div className="p-3 border-t border-[var(--color-border-default)] text-center text-xs text-[var(--color-text-tertiary)]">
          Projects from ~/projects
        </div>
      </div>
    </div>
  );
}



#########################
### client/src/components/ProjectTabs.tsx
import { useRef, useEffect } from 'react';

export interface Project {
  id: string;
  path: string;
  name: string;
  lastAccessed?: string;
}

interface ProjectTabsProps {
  projects: Project[];
  activeProjectId: string | null;
  streamingProjectIds: Set<string>;
  onSelectProject: (projectId: string) => void;
  onCloseProject: (projectId: string) => void;
  onAddProject: () => void;
}

export default function ProjectTabs({
  projects,
  activeProjectId,
  streamingProjectIds,
  onSelectProject,
  onCloseProject,
  onAddProject,
}: ProjectTabsProps) {
  const scrollRef = useRef<HTMLDivElement>(null);
  const activeTabRef = useRef<HTMLButtonElement>(null);

  // Scroll active tab into view
  useEffect(() => {
    if (activeTabRef.current && scrollRef.current) {
      activeTabRef.current.scrollIntoView({
        behavior: 'smooth',
        block: 'nearest',
        inline: 'center',
      });
    }
  }, [activeProjectId]);

  return (
    <div className="flex items-center border-b border-[var(--color-border-default)] bg-[var(--color-bg-secondary)]">
      {/* Add project button */}
      <button
        onClick={onAddProject}
        className="flex-shrink-0 p-2 px-3 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-hover)] transition-colors border-r border-[var(--color-border-default)]"
        title="Open project"
        aria-label="Open project"
      >
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
          <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
        </svg>
      </button>

      {/* Scrollable tabs container */}
      <div
        ref={scrollRef}
        className="flex-1 overflow-x-auto scrollbar-hide"
        style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
      >
        <div className="flex">
          {projects.map((project) => {
            const isActive = project.id === activeProjectId;
            const isStreaming = streamingProjectIds.has(project.id);

            return (
              <button
                key={project.id}
                ref={isActive ? activeTabRef : undefined}
                onClick={() => onSelectProject(project.id)}
                className={`
                  group flex items-center gap-2 px-3 py-2 text-sm font-medium whitespace-nowrap
                  border-r border-[var(--color-border-default)] transition-colors min-w-0
                  ${isActive
                    ? 'bg-[var(--color-bg-primary)] text-[var(--color-text-primary)] border-b-2 border-b-[var(--color-accent)]'
                    : 'text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] hover:bg-[var(--color-bg-hover)]'
                  }
                `}
              >
                {/* Streaming indicator */}
                {isStreaming && (
                  <span className="w-2 h-2 bg-[var(--color-accent)] rounded-full animate-pulse flex-shrink-0" />
                )}

                {/* Project name */}
                <span className="truncate max-w-[120px]">{project.name}</span>

                {/* Close button */}
                <button
                  onClick={(e) => {
                    e.stopPropagation();
                    onCloseProject(project.id);
                  }}
                  className={`
                    flex-shrink-0 p-0.5 rounded hover:bg-[var(--color-border-emphasis)] transition-colors
                    ${isActive ? 'text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)]' : 'text-[var(--color-text-tertiary)] hover:text-[var(--color-text-secondary)] opacity-0 group-hover:opacity-100'}
                  `}
                  title="Close project"
                  aria-label={`Close ${project.name}`}
                >
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-3.5 w-3.5" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
                  </svg>
                </button>
              </button>
            );
          })}
        </div>
      </div>
    </div>
  );
}



#########################
### client/src/components/StreamingResponse.tsx
import { useState, useMemo, memo } from 'react';
import ToolStack from './ToolStack';
import type { ToolActivity } from './types';
export type { ToolActivity };

interface StreamingResponseProps {
  thinking?: string;
  activity?: ToolActivity[];
  content?: string;
  isStreaming?: boolean;
  task?: string;
  startedAt?: string;
  completedAt?: string;
}

// Format elapsed time
function formatElapsedTime(startedAt: string, completedAt?: string): string {
  const start = new Date(startedAt).getTime();
  const end = completedAt ? new Date(completedAt).getTime() : Date.now();
  const elapsed = Math.floor((end - start) / 1000);

  if (elapsed < 60) return `${elapsed}s`;
  const minutes = Math.floor(elapsed / 60);
  const seconds = elapsed % 60;
  return `${minutes}m ${seconds}s`;
}

// Render inline formatting (bold, italic, code, links)
function renderInline(text: string): React.ReactNode[] {
  const parts: React.ReactNode[] = [];
  let remaining = text;
  let key = 0;

  while (remaining.length > 0) {
    // Bold: **text** or __text__
    const boldMatch = remaining.match(/^(\*\*|__)(.+?)\1/);
    if (boldMatch) {
      parts.push(<strong key={key++} className="font-semibold text-[var(--color-text-primary)]">{boldMatch[2]}</strong>);
      remaining = remaining.slice(boldMatch[0].length);
      continue;
    }

    // Italic: *text* or _text_
    const italicMatch = remaining.match(/^(\*|_)([^*_]+)\1/);
    if (italicMatch) {
      parts.push(<em key={key++} className="italic text-[var(--color-text-secondary)]">{italicMatch[2]}</em>);
      remaining = remaining.slice(italicMatch[0].length);
      continue;
    }

    // Inline code: `code`
    const codeMatch = remaining.match(/^`([^`]+)`/);
    if (codeMatch) {
      parts.push(
        <code key={key++} className="px-1.5 py-0.5 bg-[var(--color-bg-primary)] rounded text-sm font-mono text-[#d4a574]">
          {codeMatch[1]}
        </code>
      );
      remaining = remaining.slice(codeMatch[0].length);
      continue;
    }

    // Link: [text](url)
    const linkMatch = remaining.match(/^\[([^\]]+)\]\(([^)]+)\)/);
    if (linkMatch) {
      parts.push(
        <a key={key++} href={linkMatch[2]} target="_blank" rel="noopener noreferrer"
           className="inline-flex items-center gap-1 text-[var(--color-accent)] hover:text-[#d97a5a] underline decoration-[var(--color-accent-muted)] hover:decoration-[#d97a5a] underline-offset-2">
          {linkMatch[1]}
          <svg className="w-3 h-3 shrink-0" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M4.25 5.5a.75.75 0 00-.75.75v8.5c0 .414.336.75.75.75h8.5a.75.75 0 00.75-.75v-4a.75.75 0 011.5 0v4A2.25 2.25 0 0112.75 17h-8.5A2.25 2.25 0 012 14.75v-8.5A2.25 2.25 0 014.25 4h5a.75.75 0 010 1.5h-5zm7.25-1.25a.75.75 0 01.75-.75h4.5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0V6.31l-5.72 5.72a.75.75 0 11-1.06-1.06l5.72-5.72h-2.69a.75.75 0 01-.75-.75z" clipRule="evenodd" />
          </svg>
        </a>
      );
      remaining = remaining.slice(linkMatch[0].length);
      continue;
    }

    // Bare URL: https://... or http://...
    const urlMatch = remaining.match(/^(https?:\/\/[^\s<>)"']+)/);
    if (urlMatch) {
      const url = urlMatch[1];
      // Clean trailing punctuation that's likely not part of URL
      const cleanUrl = url.replace(/[.,;:!?)]+$/, '');
      const trailingPunct = url.slice(cleanUrl.length);
      // Show shortened display text for long URLs
      const displayUrl = cleanUrl.length > 40
        ? cleanUrl.slice(0, 35) + '...'
        : cleanUrl;
      parts.push(
        <a key={key++} href={cleanUrl} target="_blank" rel="noopener noreferrer"
           className="inline-flex items-center gap-1 text-[var(--color-accent)] hover:text-[#d97a5a] underline decoration-[var(--color-accent-muted)] hover:decoration-[#d97a5a] underline-offset-2 break-all">
          {displayUrl}
          <svg className="w-3 h-3 shrink-0" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M4.25 5.5a.75.75 0 00-.75.75v8.5c0 .414.336.75.75.75h8.5a.75.75 0 00.75-.75v-4a.75.75 0 011.5 0v4A2.25 2.25 0 0112.75 17h-8.5A2.25 2.25 0 012 14.75v-8.5A2.25 2.25 0 014.25 4h5a.75.75 0 010 1.5h-5zm7.25-1.25a.75.75 0 01.75-.75h4.5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0V6.31l-5.72 5.72a.75.75 0 11-1.06-1.06l5.72-5.72h-2.69a.75.75 0 01-.75-.75z" clipRule="evenodd" />
          </svg>
        </a>
      );
      if (trailingPunct) parts.push(trailingPunct);
      remaining = remaining.slice(url.length);
      continue;
    }

    // Regular text until next special char or URL
    const nextSpecial = remaining.search(/[*_`\[]|https?:\/\//);
    if (nextSpecial === -1) {
      parts.push(remaining);
      break;
    } else if (nextSpecial === 0) {
      // Special char that didn't match a pattern - treat as literal
      parts.push(remaining[0]);
      remaining = remaining.slice(1);
    } else {
      parts.push(remaining.slice(0, nextSpecial));
      remaining = remaining.slice(nextSpecial);
    }
  }

  return parts;
}

// Parse and render markdown-like content
function TextBlock({ text, isStreaming }: { text: string; isStreaming?: boolean }) {
  const lines = text.split('\n');
  const elements: React.ReactNode[] = [];
  let i = 0;
  let key = 0;

  while (i < lines.length) {
    const line = lines[i];

    // Fenced code block: ```lang ... ```
    if (line.startsWith('```')) {
      const lang = line.slice(3).trim();
      const codeLines: string[] = [];
      i++;
      while (i < lines.length && !lines[i].startsWith('```')) {
        codeLines.push(lines[i]);
        i++;
      }
      i++; // skip closing ```
      elements.push(
        <div key={key++} className="my-2">
          {lang && <div className="text-xs text-[var(--color-text-tertiary)] mb-1">{lang}</div>}
          <pre className="p-3 bg-[var(--color-bg-primary)] rounded-lg overflow-x-auto text-sm font-mono text-[var(--color-text-secondary)] border border-[var(--color-border-default)]">
            {codeLines.join('\n')}
          </pre>
        </div>
      );
      continue;
    }

    // Header: # ## ### etc
    const headerMatch = line.match(/^(#{1,4})\s+(.+)/);
    if (headerMatch) {
      const level = headerMatch[1].length;
      const headerText = headerMatch[2];
      const sizes = ['text-xl font-bold', 'text-lg font-bold', 'text-base font-semibold', 'text-sm font-semibold'];
      elements.push(
        <div key={key++} className={`${sizes[level - 1]} text-[var(--color-text-primary)] mt-3 mb-2`}>
          {renderInline(headerText)}
        </div>
      );
      i++;
      continue;
    }

    // Bullet list: - or * or â€¢
    if (/^[\-\*â€¢]\s/.test(line)) {
      const listItems: string[] = [];
      while (i < lines.length && /^[\-\*â€¢]\s/.test(lines[i])) {
        listItems.push(lines[i].replace(/^[\-\*â€¢]\s+/, ''));
        i++;
      }
      elements.push(
        <ul key={key++} className="list-disc list-inside space-y-1 my-2 text-sm text-[var(--color-text-primary)]">
          {listItems.map((item, j) => (
            <li key={j}>{renderInline(item)}</li>
          ))}
        </ul>
      );
      continue;
    }

    // Numbered list: 1. 2. etc
    if (/^\d+\.\s/.test(line)) {
      const listItems: string[] = [];
      while (i < lines.length && /^\d+\.\s/.test(lines[i])) {
        listItems.push(lines[i].replace(/^\d+\.\s+/, ''));
        i++;
      }
      elements.push(
        <ol key={key++} className="list-decimal list-inside space-y-1 my-2 text-sm text-[var(--color-text-primary)]">
          {listItems.map((item, j) => (
            <li key={j}>{renderInline(item)}</li>
          ))}
        </ol>
      );
      continue;
    }

    // Empty line = paragraph break
    if (line.trim() === '') {
      i++;
      continue;
    }

    // Regular paragraph - collect consecutive non-empty lines
    const paraLines: string[] = [];
    while (i < lines.length && lines[i].trim() !== '' && !lines[i].startsWith('```') &&
           !lines[i].match(/^#{1,4}\s/) && !/^[\-\*â€¢]\s/.test(lines[i]) && !/^\d+\.\s/.test(lines[i])) {
      paraLines.push(lines[i]);
      i++;
    }
    if (paraLines.length > 0) {
      elements.push(
        <p key={key++} className="text-sm text-[var(--color-text-primary)] leading-relaxed my-2">
          {renderInline(paraLines.join(' '))}
        </p>
      );
    }
  }

  // Add streaming cursor to the last element
  if (isStreaming && elements.length > 0) {
    const cursor = <span key="cursor" className="inline-block w-2 h-4 bg-[var(--color-accent)] ml-0.5 animate-pulse" />;
    const last = elements[elements.length - 1];
    // Wrap last element with cursor
    elements[elements.length - 1] = (
      <span key={`last-${key}`} className="contents">
        {last}
        {cursor}
      </span>
    );
  }

  if (elements.length === 0) return null;

  return <div className="space-y-1">{elements}</div>;
}

// Thinking indicator
function ThinkingBlock({ thinking, isStreaming }: { thinking: string; isStreaming?: boolean }) {
  const [expanded, setExpanded] = useState(false);

  if (!thinking) return null;

  return (
    <div className="border-l-2 border-[var(--color-border-default)] pl-3 py-1">
      <button
        onClick={() => setExpanded(!expanded)}
        className="flex items-center gap-2 text-xs text-[var(--color-text-tertiary)] hover:text-[var(--color-text-secondary)] transition-colors"
      >
        <span className={`transform transition-transform ${expanded ? 'rotate-90' : ''}`}>â–¶</span>
        <span className="italic">Thinking</span>
        {isStreaming && <span className="w-1.5 h-1.5 bg-[var(--color-text-tertiary)] rounded-full animate-pulse" />}
      </button>
      {expanded && (
        <div className="mt-2 text-xs text-[var(--color-text-tertiary)] italic whitespace-pre-wrap max-h-32 overflow-y-auto">
          {thinking}
        </div>
      )}
    </div>
  );
}

// Main streaming response component (text only - tools shown in ToolStack)
export default memo(function StreamingResponse({
  thinking,
  activity = [],
  content,
  isStreaming = false,
  task,
  startedAt,
  completedAt,
}: StreamingResponseProps) {
  // Calculate elapsed time
  const elapsedTime = startedAt ? formatElapsedTime(startedAt, isStreaming ? undefined : completedAt) : '';

  // Determine current phase
  const phase = useMemo(() => {
    if (!isStreaming) return 'done';
    if (content) return 'responding';
    if (activity.length > 0) return 'working';
    if (thinking) return 'thinking';
    return 'starting';
  }, [isStreaming, content, activity.length, thinking]);

  const phaseLabels: Record<string, { label: string; color: string }> = {
    starting: { label: 'Starting...', color: 'text-[var(--color-text-secondary)]' },
    thinking: { label: 'Thinking...', color: 'text-[var(--color-text-secondary)]' },
    working: { label: 'Working...', color: 'text-[var(--color-accent)]' },
    responding: { label: 'Responding...', color: 'text-green-400' },
    done: { label: 'Done', color: 'text-[var(--color-text-tertiary)]' },
  };

  const currentPhase = phaseLabels[phase];

  return (
    <div className="bg-[var(--color-bg-secondary)] rounded-xl border border-[var(--color-border-default)] overflow-hidden">
      {/* Header */}
      <div className="px-4 py-2.5 bg-[var(--color-bg-tertiary)] border-b border-[var(--color-border-default)] flex items-center justify-between">
        <div className="flex items-center gap-3 min-w-0 flex-1">
          {isStreaming ? (
            <div className="flex items-center gap-2">
              <span className="w-2 h-2 bg-[var(--color-accent)] rounded-full animate-pulse" />
              <span className={`text-sm font-medium ${currentPhase.color}`}>{currentPhase.label}</span>
            </div>
          ) : (
            <span className="text-sm text-[var(--color-text-tertiary)]">Response</span>
          )}
          {task && (
            <span className="text-xs text-[var(--color-text-tertiary)] truncate" title={task}>
              {task.length > 50 ? task.substring(0, 50) + '...' : task}
            </span>
          )}
        </div>
        {elapsedTime && (
          <span className="text-xs text-[var(--color-text-tertiary)] tabular-nums shrink-0">{elapsedTime}</span>
        )}
      </div>

      {/* Content area */}
      <div className="p-4 space-y-4">
        {/* Thinking (collapsed by default) */}
        {thinking && <ThinkingBlock thinking={thinking} isStreaming={isStreaming && phase === 'thinking'} />}

        {/* Response text */}
        {content && (
          <div>
            <TextBlock text={content} isStreaming={isStreaming && phase === 'responding'} />
          </div>
        )}

        {/* Loading state when nothing to show yet */}
        {isStreaming && !thinking && !content && (
          <div className="flex items-center justify-center py-4">
            <div className="flex space-x-1">
              <div className="w-2 h-2 bg-[var(--color-text-tertiary)] rounded-full animate-bounce" />
              <div className="w-2 h-2 bg-[var(--color-text-tertiary)] rounded-full animate-bounce [animation-delay:0.1s]" />
              <div className="w-2 h-2 bg-[var(--color-text-tertiary)] rounded-full animate-bounce [animation-delay:0.2s]" />
            </div>
          </div>
        )}
      </div>

      {/* Tool activity (shown for both streaming and historical messages) */}
      {activity && activity.length > 0 && (
        <ToolStack activity={activity} isStreaming={isStreaming} />
      )}
    </div>
  );
})



#########################
### client/src/components/ToolStack.tsx
import { useState, useEffect, useRef, useCallback } from 'react';
import { createPortal } from 'react-dom';
import type { ToolActivity } from './types';

// Tool category colors and icons
const toolConfig: Record<string, { icon: string; color: string; bg: string; border: string }> = {
  Read: { icon: 'ğŸ“„', color: 'text-cyan-400', bg: 'bg-cyan-950/30', border: 'border-cyan-500/50' },
  Write: { icon: 'âœï¸', color: 'text-green-400', bg: 'bg-green-950/30', border: 'border-green-500/50' },
  Edit: { icon: 'ğŸ”§', color: 'text-green-400', bg: 'bg-green-950/30', border: 'border-green-500/50' },
  Bash: { icon: 'ğŸ’»', color: 'text-yellow-400', bg: 'bg-yellow-950/30', border: 'border-yellow-500/50' },
  Glob: { icon: 'ğŸ”', color: 'text-purple-400', bg: 'bg-purple-950/30', border: 'border-purple-500/50' },
  Grep: { icon: 'ğŸ”', color: 'text-purple-400', bg: 'bg-purple-950/30', border: 'border-purple-500/50' },
  Task: { icon: 'ğŸ¤–', color: 'text-blue-400', bg: 'bg-blue-950/30', border: 'border-blue-500/50' },
  WebFetch: { icon: 'ğŸŒ', color: 'text-blue-400', bg: 'bg-blue-950/30', border: 'border-blue-500/50' },
  WebSearch: { icon: 'ğŸ”', color: 'text-blue-400', bg: 'bg-blue-950/30', border: 'border-blue-500/50' },
  TodoWrite: { icon: 'ğŸ“', color: 'text-orange-400', bg: 'bg-orange-950/30', border: 'border-orange-500/50' },
  AskUserQuestion: { icon: 'â“', color: 'text-pink-400', bg: 'bg-pink-950/30', border: 'border-pink-500/50' },
};

const defaultToolConfig = { icon: 'âš™ï¸', color: 'text-[var(--color-text-secondary)]', bg: 'bg-[var(--color-bg-secondary)]', border: 'border-[var(--color-border-default)]' };

function getToolConfig(tool: string) {
  return toolConfig[tool] || defaultToolConfig;
}

// Format timestamp as relative time or HH:MM:SS
function formatTimestamp(timestamp: number): string {
  const now = Date.now();
  const diff = Math.floor((now - timestamp) / 1000);

  if (diff < 5) return 'now';
  if (diff < 60) return `${diff}s ago`;
  if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;

  // Fall back to absolute time
  const date = new Date(timestamp);
  return date.toLocaleTimeString('en-US', { hour12: false });
}

// Parse activity into paired tool uses and results
function parseActivityPairs(activity: ToolActivity[]) {
  const pairs: Array<{
    tool: string;
    input: Record<string, unknown>;
    result?: { output?: string; error?: string };
    timestamp: number;
  }> = [];

  let pendingToolUse: { tool: string; input: Record<string, unknown>; timestamp: number } | null = null;

  for (const item of activity) {
    if (item.type === 'tool_use') {
      if (pendingToolUse) {
        pairs.push(pendingToolUse);
      }
      pendingToolUse = { tool: item.tool, input: item.input || {}, timestamp: item.timestamp };
    } else if (item.type === 'tool_result' && pendingToolUse) {
      pairs.push({
        ...pendingToolUse,
        result: { output: item.output, error: item.error },
      });
      pendingToolUse = null;
    }
  }

  if (pendingToolUse) {
    pairs.push(pendingToolUse);
  }

  return pairs;
}

// Fullscreen detail modal for tool use
function ToolDetailModal({ tool, input, result, timestamp, onClose }: {
  tool: string;
  input: Record<string, unknown>;
  result?: { output?: string; error?: string };
  timestamp: number;
  onClose: () => void;
}) {
  const config = getToolConfig(tool);

  // Close on Escape key
  useEffect(() => {
    const handleKey = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
    };
    window.addEventListener('keydown', handleKey);
    return () => window.removeEventListener('keydown', handleKey);
  }, [onClose]);

  // Prevent body scroll while modal is open
  useEffect(() => {
    document.body.style.overflow = 'hidden';
    return () => { document.body.style.overflow = ''; };
  }, []);

  return createPortal(
    <div
      className="fixed inset-0 z-50 flex flex-col bg-black/80 backdrop-blur-sm"
      onClick={onClose}
    >
      <div
        className="flex-1 flex flex-col m-2 sm:m-4 rounded-xl border border-[var(--color-border-default)] bg-[var(--color-bg-primary)] overflow-hidden"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Modal header */}
        <div className="flex items-center gap-3 px-4 py-3 border-b border-[var(--color-border-default)] bg-[var(--color-bg-tertiary)] shrink-0">
          <span className="text-lg">{config.icon}</span>
          <span className={`font-semibold text-sm ${config.color}`}>{tool}</span>
          {!!input.file_path && (
            <span className="text-xs text-[var(--color-text-secondary)] font-mono truncate">{String(input.file_path)}</span>
          )}
          <div className="flex-1" />
          {result?.error ? (
            <span className="text-xs text-red-400 font-medium">Error</span>
          ) : result ? (
            <span className="text-xs text-green-400 font-medium">Done</span>
          ) : (
            <span className="text-xs text-[var(--color-accent)] font-medium">Running...</span>
          )}
          <span className="text-xs text-[var(--color-text-tertiary)] tabular-nums">{formatTimestamp(timestamp)}</span>
          <button
            onClick={onClose}
            className="ml-2 text-[var(--color-text-tertiary)] hover:text-[var(--color-text-primary)] transition-colors text-xl leading-none px-1"
          >
            Ã—
          </button>
        </div>

        {/* Modal body - scrollable */}
        <div className="flex-1 overflow-y-auto p-4 space-y-4 text-sm">
          {/* Edit diff view */}
          {tool === 'Edit' && !!input.old_string && (
            <div className="space-y-4">
              <div>
                <div className="text-red-400 mb-2 flex items-center gap-1 font-medium text-xs">
                  <span className="font-bold">âˆ’</span> Removed
                </div>
                <pre className="p-3 bg-red-950/40 border-l-2 border-red-500 rounded-lg text-red-200 whitespace-pre-wrap overflow-x-auto">
                  {String(input.old_string)}
                </pre>
              </div>
              <div>
                <div className="text-green-400 mb-2 flex items-center gap-1 font-medium text-xs">
                  <span className="font-bold">+</span> Added
                </div>
                <pre className="p-3 bg-green-950/40 border-l-2 border-green-500 rounded-lg text-green-200 whitespace-pre-wrap overflow-x-auto">
                  {String(input.new_string || '')}
                </pre>
              </div>
            </div>
          )}

          {/* Write content */}
          {tool === 'Write' && Boolean(input.content) && (
            <div>
              <div className="text-green-400 mb-2 font-medium text-xs">Content</div>
              <pre className="p-3 bg-green-950/40 border-l-2 border-green-500 rounded-lg text-green-200 whitespace-pre-wrap overflow-x-auto">
                {String(input.content)}
              </pre>
            </div>
          )}

          {/* Bash command */}
          {tool === 'Bash' && Boolean(input.command) && (
            <div>
              <div className="text-yellow-400 mb-2 font-medium text-xs">Command</div>
              <pre className="p-3 bg-[#111] rounded-lg text-yellow-200 font-mono whitespace-pre-wrap overflow-x-auto">
                <span className="text-yellow-500">$</span> {String(input.command)}
              </pre>
            </div>
          )}

          {/* Read - just show file path */}
          {tool === 'Read' && Boolean(input.file_path) && !input.content && (
            <div>
              <div className="text-cyan-400 mb-2 font-medium text-xs">File</div>
              <pre className="p-3 bg-[#111] rounded-lg text-cyan-200 font-mono">{String(input.file_path)}</pre>
            </div>
          )}

          {/* Generic input for other tools */}
          {!['Read', 'Write', 'Edit', 'Bash'].includes(tool) && Object.keys(input).length > 0 && (
            <div>
              <div className="text-[var(--color-text-secondary)] mb-2 font-medium text-xs">Input</div>
              <pre className="p-3 bg-[var(--color-bg-secondary)] rounded-lg text-[var(--color-text-secondary)] whitespace-pre-wrap overflow-x-auto">
                {JSON.stringify(input, null, 2)}
              </pre>
            </div>
          )}

          {/* Result output */}
          {result?.output && (
            <div>
              <div className="text-[var(--color-text-secondary)] mb-2 font-medium text-xs">Output</div>
              <pre className="p-3 bg-[var(--color-bg-secondary)] rounded-lg text-[var(--color-text-secondary)] whitespace-pre-wrap overflow-x-auto">
                {result.output}
              </pre>
            </div>
          )}

          {/* Error */}
          {result?.error && (
            <div>
              <div className="text-red-400 mb-2 font-medium text-xs">Error</div>
              <div className="text-red-400 bg-red-950/30 p-3 rounded-lg whitespace-pre-wrap">
                {result.error}
              </div>
            </div>
          )}
        </div>
      </div>
    </div>,
    document.body
  );
}

// Compact tool card for the stack
function StackToolCard({ tool, input, result, timestamp, isLatest, onOpenDetail }: {
  tool: string;
  input: Record<string, unknown>;
  result?: { output?: string; error?: string };
  timestamp: number;
  isLatest?: boolean;
  onOpenDetail: () => void;
}) {
  const config = getToolConfig(tool);

  // Get a summary based on tool type
  const getSummary = () => {
    if (['Read', 'Write', 'Edit'].includes(tool) && input.file_path) {
      return String(input.file_path).split('/').slice(-2).join('/');
    }
    if (tool === 'Bash' && input.command) {
      const cmd = String(input.command);
      return cmd.length > 40 ? cmd.substring(0, 40) + '...' : cmd;
    }
    if (['Glob', 'Grep'].includes(tool) && input.pattern) {
      return String(input.pattern).substring(0, 30);
    }
    if (tool === 'WebSearch' && input.query) {
      return `"${String(input.query).substring(0, 30)}"`;
    }
    if (tool === 'Task' && input.prompt) {
      return String(input.prompt).substring(0, 40) + '...';
    }
    return null;
  };

  const summary = getSummary();

  return (
    <div className={`rounded-lg border ${config.border} ${config.bg} overflow-hidden ${isLatest ? 'ring-1 ring-[var(--color-accent)]/50' : ''}`}>
      <button
        onClick={onOpenDetail}
        className="w-full px-3 py-2 flex items-center gap-2 text-left hover:bg-white/5 transition-colors"
      >
        <span className="text-base">{config.icon}</span>
        <span className={`font-medium text-xs ${config.color}`}>{tool}</span>
        {summary && (
          <span className="text-xs text-[var(--color-text-secondary)] truncate flex-1 font-mono">{summary}</span>
        )}
        {!summary && <div className="flex-1" />}

        {/* Status indicator */}
        {result?.error ? (
          <span className="text-xs text-red-400">err</span>
        ) : result ? (
          <span className="text-xs text-green-400">ok</span>
        ) : isLatest ? (
          <span className="w-1.5 h-1.5 bg-[var(--color-accent)] rounded-full animate-pulse" />
        ) : null}

        {/* Timestamp */}
        <span className="text-xs text-[var(--color-text-tertiary)] tabular-nums">{formatTimestamp(timestamp)}</span>

        {/* Detail arrow */}
        <span className="text-xs text-[var(--color-text-tertiary)]">â–¶</span>
      </button>
    </div>
  );
}

interface ToolStackProps {
  activity: ToolActivity[];
  isStreaming: boolean;
}

export default function ToolStack({ activity, isStreaming }: ToolStackProps) {
  const scrollRef = useRef<HTMLDivElement>(null);
  const toolPairs = parseActivityPairs(activity);
  const [modalIndex, setModalIndex] = useState<number | null>(null);

  const closeModal = useCallback(() => setModalIndex(null), []);

  // Auto-scroll to bottom when new tools arrive
  useEffect(() => {
    if (scrollRef.current && toolPairs.length > 0) {
      scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
    }
  }, [toolPairs.length]);

  // Don't render if no tools
  if (toolPairs.length === 0) {
    return null;
  }

  const modalPair = modalIndex !== null ? toolPairs[modalIndex] : null;

  return (
    <div className="border-t border-[var(--color-border-default)] bg-[var(--color-bg-primary)]/80">
      {/* Header */}
      <div className="px-3 py-1.5 flex items-center gap-2 border-b border-[var(--color-border-subtle)]">
        <span className="text-xs text-[var(--color-text-tertiary)] font-medium">Tools</span>
        <span className="text-xs text-[var(--color-text-muted)]">({toolPairs.length})</span>
        {isStreaming && (
          <span className="w-1.5 h-1.5 bg-[var(--color-accent)] rounded-full animate-pulse" />
        )}
      </div>

      {/* Scrollable tool list */}
      <div
        ref={scrollRef}
        className="max-h-[30vh] overflow-y-auto px-3 py-2 space-y-1.5"
      >
        {toolPairs.map((pair, i) => (
          <StackToolCard
            key={i}
            tool={pair.tool}
            input={pair.input}
            result={pair.result}
            timestamp={pair.timestamp}
            isLatest={isStreaming && i === toolPairs.length - 1 && !pair.result}
            onOpenDetail={() => setModalIndex(i)}
          />
        ))}
      </div>

      {/* Detail modal */}
      {modalPair && (
        <ToolDetailModal
          tool={modalPair.tool}
          input={modalPair.input}
          result={modalPair.result}
          timestamp={modalPair.timestamp}
          onClose={closeModal}
        />
      )}
    </div>
  );
}



#########################
### client/src/components/types.ts
export interface ToolActivity {
  type: 'tool_use' | 'tool_result';
  tool: string;
  input?: Record<string, unknown>;
  output?: string;
  error?: string;
  timestamp: number;
}



#########################
### client/src/index.css
@import "tailwindcss";

@theme {
  --font-sans: 'JetBrains Mono', ui-monospace, 'Cascadia Code', 'Fira Code', monospace;
  --font-mono: 'JetBrains Mono', ui-monospace, 'Cascadia Code', 'Fira Code', monospace;

  /* Anthropic warm dark palette */
  --color-bg-primary: #1a1a1a;
  --color-bg-secondary: #222222;
  --color-bg-tertiary: #2a2a2a;
  --color-bg-elevated: #2e2e2e;
  --color-bg-hover: #333333;

  --color-border-default: #333333;
  --color-border-subtle: #2a2a2a;
  --color-border-emphasis: #444444;

  --color-text-primary: #e8e4e0;
  --color-text-secondary: #a09890;
  --color-text-tertiary: #706860;
  --color-text-muted: #585048;

  --color-accent: #c96442;
  --color-accent-hover: #b85838;
  --color-accent-muted: #c9644230;
}

body {
  background: var(--color-bg-primary);
  color: var(--color-text-primary);
  font-feature-settings: 'liga' 1, 'calt' 1;
  letter-spacing: -0.01em;
}

::-webkit-scrollbar {
  width: 6px;
  height: 6px;
}
::-webkit-scrollbar-track {
  background: transparent;
}
::-webkit-scrollbar-thumb {
  background: #3a3a3a;
  border-radius: 3px;
}
::-webkit-scrollbar-thumb:hover {
  background: #4a4a4a;
}

::selection {
  background: var(--color-accent-muted);
  color: var(--color-text-primary);
}



#########################
### client/src/main.tsx
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import './index.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);



#########################
### client/src/pages/Chat.tsx
import { useState, useEffect, useRef, useCallback, useMemo } from 'react';
import ProjectTabs, { type Project } from '../components/ProjectTabs';
import ProjectPicker from '../components/ProjectPicker';
import StreamingResponse, { type ToolActivity } from '../components/StreamingResponse';
import ChatInput from '../components/ChatInput';
import GitStatus from '../components/GitStatus';
import { apiFetch } from '../lib/api';


interface Props {
  token?: string | null;
  onNavigate: (route: 'home' | 'chat' | 'pair') => void;
}

interface OutputChunk {
  text: string;
  timestamp: number;
  afterTool?: string;
}

interface Message {
  role: 'user' | 'assistant';
  content: string;
  task?: string;              // user's original prompt (for assistant messages)
  chunks?: OutputChunk[];     // structured output chunks
  thinking?: string;
  activity?: ToolActivity[];
  startedAt?: string;
  completedAt?: string;
}

interface EncryptedData {
  iv: string;
  ct: string;
  tag: string;
}

async function generateKeyPair() {
  return crypto.subtle.generateKey(
    { name: 'ECDH', namedCurve: 'P-256' },
    true,
    ['deriveBits']
  );
}

async function exportPublicKey(key: CryptoKey): Promise<string> {
  const exported = await crypto.subtle.exportKey('raw', key);
  return btoa(String.fromCharCode(...new Uint8Array(exported)));
}

async function importPublicKey(base64: string): Promise<CryptoKey> {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return crypto.subtle.importKey(
    'raw',
    bytes,
    { name: 'ECDH', namedCurve: 'P-256' },
    true,
    []
  );
}

async function deriveSharedSecret(privateKey: CryptoKey, peerPublicKey: CryptoKey): Promise<CryptoKey> {
  const bits = await crypto.subtle.deriveBits(
    { name: 'ECDH', public: peerPublicKey },
    privateKey,
    256
  );
  // Hash with SHA-256 to ensure consistent 32-byte key across platforms
  const hashed = await crypto.subtle.digest('SHA-256', bits);
  return crypto.subtle.importKey(
    'raw',
    hashed,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
}

async function encrypt(plaintext: string, key: CryptoKey): Promise<EncryptedData> {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encoded = new TextEncoder().encode(plaintext);
  const encrypted = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv },
    key,
    encoded
  );
  const ct = new Uint8Array(encrypted.slice(0, -16));
  const tag = new Uint8Array(encrypted.slice(-16));
  return {
    iv: btoa(String.fromCharCode(...iv)),
    ct: btoa(String.fromCharCode(...ct)),
    tag: btoa(String.fromCharCode(...tag)),
  };
}

async function decrypt(data: EncryptedData, key: CryptoKey): Promise<string> {
  const iv = Uint8Array.from(atob(data.iv), c => c.charCodeAt(0));
  const ct = Uint8Array.from(atob(data.ct), c => c.charCodeAt(0));
  const tag = Uint8Array.from(atob(data.tag), c => c.charCodeAt(0));
  const combined = new Uint8Array(ct.length + tag.length);
  combined.set(ct);
  combined.set(tag, ct.length);
  const decrypted = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv },
    key,
    combined
  );
  return new TextDecoder().decode(decrypted);
}

type View = 'pairing' | 'pin' | 'chat';

// Per-project state container
interface ProjectState {
  messages: Message[];
  isStreaming: boolean;
  currentThinking: string;
  currentResponse: string;
  currentActivity: ToolActivity[];
  currentTask: string;         // The user prompt for current streaming task
  taskStartTime: number | null; // When the current task started
}

function createEmptyProjectState(): ProjectState {
  return {
    messages: [],
    isStreaming: false,
    currentThinking: '',
    currentResponse: '',
    currentActivity: [],
    currentTask: '',
    taskStartTime: null,
  };
}

export default function Chat({ token = null }: Props) {
  const [view, setView] = useState<View>('pairing');
  const [pin, setPin] = useState('');
  const [error, setError] = useState('');

  // Multi-project state
  const [openProjects, setOpenProjects] = useState<Project[]>([]);
  const [activeProjectId, setActiveProjectId] = useState<string | null>(null);
  const [projectStates, setProjectStates] = useState<Map<string, ProjectState>>(new Map());
  const [streamingProjectIds, setStreamingProjectIds] = useState<Set<string>>(new Set());
  const [showProjectPicker, setShowProjectPicker] = useState(false);
  const tabsRestoredRef = useRef(false);

  // Refs for streaming (per-project)
  const thinkingRefs = useRef<Map<string, string>>(new Map());
  const responseRefs = useRef<Map<string, string>>(new Map());
  const activityRefs = useRef<Map<string, ToolActivity[]>>(new Map());

  const wsRef = useRef<WebSocket | null>(null);
  const sharedKeyRef = useRef<CryptoKey | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Reconnection state
  const [isReconnecting, setIsReconnecting] = useState(false);
  const [reconnectAttempt, setReconnectAttempt] = useState(0);
  const reconnectAttemptRef = useRef(0);
  const reconnectTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const cachedPinRef = useRef<string | null>((() => {
    try {
      const stored = localStorage.getItem('claude-remote-pin');
      if (!stored) return null;
      const { pin, exp } = JSON.parse(stored);
      if (Date.now() > exp) {
        localStorage.removeItem('claude-remote-pin');
        return null;
      }
      return pin as string;
    } catch {
      localStorage.removeItem('claude-remote-pin');
      return null;
    }
  })());
  const intentionalCloseRef = useRef(false);

  // Helper to update project state
  const updateProjectState = useCallback((projectId: string, updater: (state: ProjectState) => ProjectState) => {
    setProjectStates(prev => {
      const current = prev.get(projectId) || createEmptyProjectState();
      const updated = updater(current);
      const next = new Map(prev);
      next.set(projectId, updated);
      return next;
    });
  }, []);

  // Current active project state (for display) â€” read directly, no callback wrapper
  const activeState = (activeProjectId ? projectStates.get(activeProjectId) : null) || createEmptyProjectState();
  const messages = activeState.messages;
  const isStreaming = activeState.isStreaming;
  const currentThinking = activeState.currentThinking;
  const currentResponse = activeState.currentResponse;
  const currentActivity = activeState.currentActivity;
  const currentTask = activeState.currentTask;
  const taskStartTime = activeState.taskStartTime;

  // Memoize derived values to avoid re-creating on every render
  const openProjectIds = useMemo(() => new Set(openProjects.map(p => p.id)), [openProjects]);

  const scrollToBottom = useCallback((force = false) => {
    if (!messagesEndRef.current) return;

    // Only auto-scroll if user is near the bottom (within 150px) or forced
    const container = messagesEndRef.current.parentElement;
    if (container && !force) {
      const { scrollTop, scrollHeight, clientHeight } = container;
      const distanceFromBottom = scrollHeight - scrollTop - clientHeight;
      if (distanceFromBottom > 150) return; // User scrolled up, don't interrupt
    }

    messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
  }, []);

  // Fetch conversation history for a specific project
  const fetchProjectConversation = useCallback(async (projectId: string, retries = 3) => {
    console.log(`Fetching conversation history for project: ${projectId}`);
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        const res = await apiFetch(`/api/projects/${encodeURIComponent(projectId)}/conversation`);
        if (!res.ok) {
          throw new Error(`Failed to fetch history: ${res.status}`);
        }
        const data = await res.json();
        console.log(`Loaded conversation for ${projectId}:`, data.messages?.length, 'messages');
        if (data.messages && data.messages.length > 0) {
          const loadedMessages = data.messages.map((m: {
            role: string;
            content: string;
            task?: string;
            chunks?: OutputChunk[];
            thinking?: string;
            activity?: ToolActivity[];
            startedAt?: string;
            completedAt?: string;
          }) => ({
            role: m.role as 'user' | 'assistant',
            content: m.content,
            task: m.task,
            chunks: m.chunks,
            thinking: m.thinking,
            activity: m.activity,
            startedAt: m.startedAt,
            completedAt: m.completedAt,
          }));
          updateProjectState(projectId, state => ({ ...state, messages: loadedMessages }));
          // Scroll to bottom after messages are rendered
          // Use requestAnimationFrame to ensure DOM is updated, then scroll
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            });
          });
        }
        return; // Success
      } catch (err) {
        console.error(`Failed to fetch project conversation (attempt ${attempt}/${retries}):`, err);
        if (attempt < retries) {
          await new Promise(resolve => setTimeout(resolve, 500 * attempt));
        }
      }
    }
    console.error('All retries failed for project conversation');
  }, [updateProjectState]);

  // Fetch streaming state for a project (to restore in-progress responses on reconnect)
  const fetchProjectStreamingState = useCallback(async (projectId: string) => {
    console.log(`Fetching streaming state for project: ${projectId}`);
    try {
      const res = await apiFetch(`/api/projects/${encodeURIComponent(projectId)}/streaming`);
      if (!res.ok) {
        throw new Error(`Failed to fetch streaming state: ${res.status}`);
      }
      const data = await res.json();
      console.log(`Streaming state for ${projectId}:`, data);

      if (data.isStreaming && data.partial) {
        // Restore streaming state
        setStreamingProjectIds(prev => {
          const next = new Set(prev);
          next.add(projectId);
          return next;
        });

        // Update refs with partial data
        if (data.partial.thinking) {
          thinkingRefs.current.set(projectId, data.partial.thinking);
        }
        if (data.partial.text) {
          responseRefs.current.set(projectId, data.partial.text);
        }
        if (data.partial.activity && data.partial.activity.length > 0) {
          activityRefs.current.set(projectId, data.partial.activity);
        }

        // Update project state with restored streaming data
        updateProjectState(projectId, state => ({
          ...state,
          isStreaming: true,
          currentThinking: data.partial.thinking || '',
          currentResponse: data.partial.text || '',
          currentActivity: data.partial.activity || [],
        }));
      }
    } catch (err) {
      console.error(`Failed to fetch streaming state for ${projectId}:`, err);
    }
  }, [updateProjectState]);

  const clearHistory = async () => {
    if (!activeProjectId) return;
    try {
      const res = await apiFetch(`/api/projects/${encodeURIComponent(activeProjectId)}/conversation`, { method: 'DELETE' });
      if (!res.ok) throw new Error(`Failed to clear history: ${res.status}`);
      updateProjectState(activeProjectId, state => ({ ...state, messages: [] }));
    } catch (err) {
      setError(`Failed to clear history: ${err}`);
    }
  };

  // Scroll to bottom when new messages arrive or project changes (force scroll)
  const messagesLength = messages.length;
  useEffect(() => {
    scrollToBottom(true);
  }, [messagesLength, activeProjectId, scrollToBottom]);

  // Scroll during streaming â€” throttle to once per 200ms to avoid layout thrash
  const scrollThrottleRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  useEffect(() => {
    if (isStreaming && !scrollThrottleRef.current) {
      scrollThrottleRef.current = setTimeout(() => {
        scrollToBottom(false);
        scrollThrottleRef.current = null;
      }, 200);
    }
  }, [currentThinking, currentResponse, currentActivity, isStreaming, scrollToBottom]);

  // Persist open tabs to localStorage (skip initial render to avoid nuking saved data)
  const initialRenderRef = useRef(true);
  useEffect(() => {
    if (initialRenderRef.current) {
      initialRenderRef.current = false;
      return;
    }
    if (openProjects.length > 0) {
      localStorage.setItem('claude-remote-open-projects', JSON.stringify(openProjects));
    } else {
      localStorage.removeItem('claude-remote-open-projects');
    }
  }, [openProjects]);

  // Persist active tab to localStorage (skip initial render)
  const initialActiveRef = useRef(true);
  useEffect(() => {
    if (initialActiveRef.current) {
      initialActiveRef.current = false;
      return;
    }
    if (activeProjectId) {
      localStorage.setItem('claude-remote-active-project', activeProjectId);
    } else {
      localStorage.removeItem('claude-remote-active-project');
    }
  }, [activeProjectId]);

  useEffect(() => {
    console.log('Chat useEffect: token =', token);
    if (token) {
      console.log('New pairing flow - clearing old credentials');
      localStorage.removeItem('claude-remote-paired');
      localStorage.removeItem('claude-remote-device-id');
      localStorage.removeItem('claude-remote-private-key');
      localStorage.removeItem('claude-remote-server-public-key');
      localStorage.removeItem('claude-remote-pin');
      cachedPinRef.current = null;
      // Stay in 'pairing' view, completePairing will run
    } else {
      const stored = localStorage.getItem('claude-remote-paired');
      if (stored) {
        // Check if we have a cached PIN â€” auto-connect if so
        const cachedPin = cachedPinRef.current;
        if (cachedPin) {
          console.log('Found cached PIN, auto-connecting...');

          // Restore tabs from localStorage immediately (don't wait for auth_ok)
          const savedProjects = localStorage.getItem('claude-remote-open-projects');
          const savedActiveId = localStorage.getItem('claude-remote-active-project');
          if (savedProjects) {
            try {
              const projects: Project[] = JSON.parse(savedProjects);
              if (projects.length > 0) {
                setOpenProjects(projects);
                const newStates = new Map<string, ProjectState>();
                projects.forEach(p => {
                  newStates.set(p.id, createEmptyProjectState());
                });
                setProjectStates(newStates);
                const activeId = savedActiveId && projects.find(p => p.id === savedActiveId)
                  ? savedActiveId
                  : projects[0].id;
                setActiveProjectId(activeId);
                tabsRestoredRef.current = true;
              }
            } catch (err) {
              console.error('Failed to restore saved projects on init:', err);
            }
          }

          setView('chat');
          setIsReconnecting(true);
          setTimeout(() => connectAndAuth(), 0);
        } else {
          console.log('Found pairing but no cached PIN, showing PIN view');
          setView('pin');
        }
      } else {
        setError('Not paired. Go to home page to scan QR code.');
      }
    }
  }, [token]); // eslint-disable-line react-hooks/exhaustive-deps

  const pairingStarted = useRef(false);

  const completePairing = useCallback(async () => {
    if (!token || pairingStarted.current) {
      return;
    }
    pairingStarted.current = true;

    console.log('Fetching server public key...');
    const getRes = await fetch(`/pair/${token}`);
    if (!getRes.ok) {
      const data = await getRes.json().catch(() => ({}));
      const msg = `Failed to get server key: ${data.error || getRes.status}`;
      console.error(msg, data);
      setError(msg);
      throw new Error(msg);
    }
    const getData = await getRes.json();
    const { serverPublicKey } = getData;
    if (!serverPublicKey) {
      const msg = 'Server returned empty public key';
      console.error(msg, getData);
      setError(msg);
      throw new Error(msg);
    }

    const keyPair = await generateKeyPair();
    const clientPublicKey = await exportPublicKey(keyPair.publicKey);
    const privateKeyJwk = await crypto.subtle.exportKey('jwk', keyPair.privateKey);

    const postRes = await fetch(`/pair/${token}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ clientPublicKey }),
    });

    if (!postRes.ok) {
      const data = await postRes.json();
      const msg = `Failed to complete pairing: ${data.error || postRes.status}`;
      console.error(msg, data);
      setError(msg);
      throw new Error(msg);
    }

    const { deviceId } = await postRes.json();
    if (!deviceId) {
      const msg = 'Server returned empty device ID';
      console.error(msg);
      setError(msg);
      throw new Error(msg);
    }

    const serverKey = await importPublicKey(serverPublicKey);
    await deriveSharedSecret(keyPair.privateKey, serverKey); // Verify key derivation works

    localStorage.setItem('claude-remote-paired', 'true');
    localStorage.setItem('claude-remote-device-id', deviceId);
    localStorage.setItem('claude-remote-private-key', JSON.stringify(privateKeyJwk));
    localStorage.setItem('claude-remote-server-public-key', serverPublicKey);

    // Hard redirect to avoid React strict mode issues
    window.location.href = '/chat';
  }, [token]);

  useEffect(() => {
    if (token && view === 'pairing') {
      completePairing().catch((err) => {
        console.error('Pairing failed:', err);
        // Error already set in completePairing
      });
    }
  }, [completePairing, token, view]);

  const restoreSharedKey = useCallback(async (): Promise<void> => {
    const privateKeyJwk = localStorage.getItem('claude-remote-private-key');
    const serverPublicKey = localStorage.getItem('claude-remote-server-public-key');

    if (!privateKeyJwk) {
      throw new Error('No private key in localStorage - device not paired');
    }
    if (!serverPublicKey) {
      throw new Error('No server public key in localStorage - device not paired');
    }

    const privateKey = await crypto.subtle.importKey(
      'jwk',
      JSON.parse(privateKeyJwk),
      { name: 'ECDH', namedCurve: 'P-256' },
      true,
      ['deriveBits']
    );
    const serverKey = await importPublicKey(serverPublicKey);
    const sharedKey = await deriveSharedSecret(privateKey, serverKey);
    sharedKeyRef.current = sharedKey;
  }, []);

  // Schedule a reconnection attempt with exponential backoff
  const scheduleReconnect = useCallback(() => {
    if (reconnectTimerRef.current) clearTimeout(reconnectTimerRef.current);
    const attempt = reconnectAttemptRef.current;
    const delay = Math.min(1000 * Math.pow(2, attempt), 30000); // 1s, 2s, 4s, ... 30s max
    console.log(`[reconnect] Scheduling attempt ${attempt + 1} in ${delay}ms`);
    reconnectAttemptRef.current = attempt + 1;
    setReconnectAttempt(attempt + 1);
    setIsReconnecting(true);
    reconnectTimerRef.current = setTimeout(() => {
      connectAndAuth();
    }, delay);
  }, []); // connectAndAuth referenced below via ref

  // Ref to break circular dependency between connectWebSocket and scheduleReconnect
  const scheduleReconnectRef = useRef(scheduleReconnect);
  scheduleReconnectRef.current = scheduleReconnect;

  const connectWebSocket = useCallback((): Promise<WebSocket> => {
    return new Promise((resolve, reject) => {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

      ws.onopen = () => {
        wsRef.current = ws;
        resolve(ws);
      };

      ws.onmessage = async (event) => {
        if (!sharedKeyRef.current) {
          console.error('[ws] Received message but sharedKeyRef is null');
          setError('Encryption key missing - please refresh the page');
          return;
        }

        let encrypted: EncryptedData;
        try {
          encrypted = JSON.parse(event.data);
        } catch (err) {
          console.error('[ws] Failed to parse message as JSON:', err);
          return;
        }

        let decrypted: string;
        try {
          decrypted = await decrypt(encrypted, sharedKeyRef.current);
        } catch (err) {
          console.error('[ws] Decryption failed:', err);
          setError('Decryption failed - keys may be mismatched. Try clearing data and re-pairing.');
          return;
        }

        let msg: {
          type: string;
          text?: string;
          thinking?: string;
          error?: string;
          projectId?: string;
          activeProjectIds?: string[];
          activity?: ToolActivity[];
          toolUse?: { tool: string; input: Record<string, unknown> };
          toolResult?: { tool: string; output?: string; error?: string };
        };
        try {
          msg = JSON.parse(decrypted);
        } catch (err) {
          console.error('[ws] Failed to parse decrypted message:', err);
          return;
        }

        // Get projectId from message (streaming events include it)
        const projectId = msg.projectId;

        if (msg.type === 'auth_ok') {
          // Successful auth â€” clear reconnection state
          setError('');
          setView('chat');
          setIsReconnecting(false);
          setReconnectAttempt(0);
          reconnectAttemptRef.current = 0;

          // Set streaming indicators for any active jobs
          const activeIds = msg.activeProjectIds || [];
          if (activeIds.length > 0) {
            console.log('Active streaming projects on reconnect:', activeIds);
            setStreamingProjectIds(new Set(activeIds.filter(id => id !== '__global__')));
            activeIds.forEach(projectId => {
              if (projectId !== '__global__') {
                updateProjectState(projectId, state => ({
                  ...state,
                  isStreaming: true,
                }));
              }
            });
          }

          // Restore tabs from localStorage, or show picker if none saved
          if (!tabsRestoredRef.current) {
            tabsRestoredRef.current = true;
            const savedProjects = localStorage.getItem('claude-remote-open-projects');
            const savedActiveId = localStorage.getItem('claude-remote-active-project');

            if (savedProjects) {
              try {
                const projects: Project[] = JSON.parse(savedProjects);
                if (projects.length > 0) {
                  setOpenProjects(projects);
                  const newStates = new Map<string, ProjectState>();
                  projects.forEach(p => {
                    const isStreaming = activeIds.includes(p.id);
                    newStates.set(p.id, {
                      ...createEmptyProjectState(),
                      isStreaming,
                    });
                  });
                  setProjectStates(newStates);
                  const activeId = savedActiveId && projects.find(p => p.id === savedActiveId)
                    ? savedActiveId
                    : projects[0].id;
                  setActiveProjectId(activeId);
                  projects.forEach(p => {
                    fetchProjectConversation(p.id);
                  });
                  return;
                }
              } catch (err) {
                console.error('Failed to restore saved projects:', err);
              }
            }
            setShowProjectPicker(true);
          } else {
            // Tabs already restored (e.g. from cached PIN init) â€” just fetch conversations
            const savedProjects = localStorage.getItem('claude-remote-open-projects');
            if (savedProjects) {
              try {
                const projects: Project[] = JSON.parse(savedProjects);
                projects.forEach(p => fetchProjectConversation(p.id));
              } catch {}
            }
          }
        } else if (msg.type === 'auth_error') {
          console.error('Auth failed:', msg.error);
          // PIN was wrong â€” clear cached PIN, drop to PIN screen
          cachedPinRef.current = null;
          localStorage.removeItem('claude-remote-pin');
          setIsReconnecting(false);
          setReconnectAttempt(0);
          reconnectAttemptRef.current = 0;
          setError(msg.error || 'Authentication failed - please re-enter PIN');
          setView('pin');
        } else if (msg.type === 'streaming_restore' && projectId) {
          console.log(`Restoring streaming state for ${projectId}:`, {
            thinking: msg.thinking?.length || 0,
            text: msg.text?.length || 0,
            activity: msg.activity?.length || 0,
          });

          if (msg.thinking) {
            thinkingRefs.current.set(projectId, msg.thinking);
          }
          if (msg.text) {
            responseRefs.current.set(projectId, msg.text);
          }
          if (msg.activity && msg.activity.length > 0) {
            activityRefs.current.set(projectId, msg.activity);
          }

          updateProjectState(projectId, state => ({
            ...state,
            isStreaming: true,
            currentThinking: msg.thinking || '',
            currentResponse: msg.text || '',
            currentActivity: msg.activity || [],
          }));
        } else if (msg.type === 'thinking' && projectId) {
          const currentThinking = thinkingRefs.current.get(projectId) || '';
          thinkingRefs.current.set(projectId, currentThinking + (msg.text || ''));
          updateProjectState(projectId, state => ({
            ...state,
            currentThinking: thinkingRefs.current.get(projectId) || ''
          }));
        } else if (msg.type === 'text' && projectId) {
          const currentResponse = responseRefs.current.get(projectId) || '';
          const delimiter = currentResponse ? '\n' : '';
          responseRefs.current.set(projectId, currentResponse + delimiter + (msg.text || ''));
          updateProjectState(projectId, state => ({
            ...state,
            currentResponse: responseRefs.current.get(projectId) || ''
          }));
        } else if (msg.type === 'tool_use' && msg.toolUse && projectId) {
          const activity: ToolActivity = {
            type: 'tool_use',
            tool: msg.toolUse.tool,
            input: msg.toolUse.input,
            timestamp: Date.now()
          };
          const currentActivity = activityRefs.current.get(projectId) || [];
          activityRefs.current.set(projectId, [...currentActivity, activity]);
          updateProjectState(projectId, state => ({
            ...state,
            currentActivity: activityRefs.current.get(projectId) || []
          }));
        } else if (msg.type === 'tool_result' && msg.toolResult && projectId) {
          const activity: ToolActivity = {
            type: 'tool_result',
            tool: msg.toolResult.tool,
            output: msg.toolResult.output,
            error: msg.toolResult.error,
            timestamp: Date.now()
          };
          const currentActivity = activityRefs.current.get(projectId) || [];
          activityRefs.current.set(projectId, [...currentActivity, activity]);
          updateProjectState(projectId, state => ({
            ...state,
            currentActivity: activityRefs.current.get(projectId) || []
          }));
        } else if (msg.type === 'done' && projectId) {
          const thinking = thinkingRefs.current.get(projectId) || '';
          const response = responseRefs.current.get(projectId) || '';
          const activity = activityRefs.current.get(projectId) || [];

          setStreamingProjectIds(prev => {
            const next = new Set(prev);
            next.delete(projectId);
            return next;
          });

          updateProjectState(projectId, state => {
            const task = state.currentTask;
            const startedAt = state.taskStartTime ? new Date(state.taskStartTime).toISOString() : undefined;
            const completedAt = new Date().toISOString();

            return {
              ...state,
              isStreaming: false,
              currentThinking: '',
              currentResponse: '',
              currentActivity: [],
              currentTask: '',
              taskStartTime: null,
              messages: (thinking || response || activity.length > 0)
                ? [...state.messages, {
                    role: 'assistant' as const,
                    content: response,
                    task: task || undefined,
                    thinking: thinking || undefined,
                    activity: activity.length > 0 ? activity : undefined,
                    startedAt,
                    completedAt,
                  }]
                : state.messages,
            };
          });

          thinkingRefs.current.delete(projectId);
          responseRefs.current.delete(projectId);
          activityRefs.current.delete(projectId);
        } else if (msg.type === 'error') {
          console.error('Server error:', msg.error);
          setError(msg.error || 'Unknown server error');
          if (projectId) {
            setStreamingProjectIds(prev => {
              const next = new Set(prev);
              next.delete(projectId);
              return next;
            });
            updateProjectState(projectId, state => ({
              ...state,
              isStreaming: false,
            }));
          }
        } else if (msg.type === 'sync_user_message' && msg.projectId) {
          // Another device sent a message â€” add it to our chat and start streaming UI
          console.log(`[sync] User message from another device for ${msg.projectId}`);
          updateProjectState(msg.projectId, state => ({
            ...state,
            messages: [...state.messages, { role: 'user' as const, content: msg.text || '' }],
            isStreaming: true,
            currentThinking: '',
            currentResponse: '',
            currentActivity: [],
            currentTask: msg.text || '',
            taskStartTime: Date.now(),
          }));
          setStreamingProjectIds(prev => new Set(prev).add(msg.projectId!));
          thinkingRefs.current.set(msg.projectId, '');
          responseRefs.current.set(msg.projectId, '');
          activityRefs.current.set(msg.projectId, []);
        } else if (msg.type === 'sync_cancel' && msg.projectId) {
          // Another device cancelled â€” stop streaming UI
          console.log(`[sync] Cancel from another device for ${msg.projectId}`);
          setStreamingProjectIds(prev => {
            const next = new Set(prev);
            next.delete(msg.projectId!);
            return next;
          });
          updateProjectState(msg.projectId, state => ({
            ...state,
            isStreaming: false,
          }));
        } else {
          console.log('Unknown message type:', msg.type, msg);
        }
      };

      ws.onclose = (event) => {
        console.log(`[ws] Closed: code=${event.code} reason="${event.reason || 'none'}"`);
        wsRef.current = null;

        // Don't reconnect if we closed intentionally
        if (intentionalCloseRef.current) {
          intentionalCloseRef.current = false;
          return;
        }

        if (event.code !== 1000) {
          // Unexpected close â€” try to auto-reconnect if we have a cached PIN
          if (cachedPinRef.current) {
            // DON'T clear streaming state â€” server keeps jobs running, we'll restore on reconnect
            scheduleReconnectRef.current();
          } else {
            // No cached PIN â€” must go to PIN screen
            setError('Connection lost. Please re-enter PIN.');
            setView('pin');
          }
        }
      };

      ws.onerror = (event) => {
        // Just log â€” onclose will fire after this and handle reconnection
        console.error('[ws] Connection error', event);
        reject(new Error('WebSocket connection failed'));
      };
    });
  }, [updateProjectState]);

  // Connect + authenticate in one shot (used by reconnect loop and auto-login)
  const connectAndAuth = useCallback(async () => {
    const pinToUse = cachedPinRef.current;
    if (!pinToUse) {
      console.log('[reconnect] No cached PIN, dropping to PIN screen');
      setIsReconnecting(false);
      setReconnectAttempt(0);
      setView('pin');
      return;
    }

    // Ensure shared key is ready
    if (!sharedKeyRef.current) {
      try {
        await restoreSharedKey();
      } catch (err) {
        console.error('[reconnect] Failed to restore shared key:', err);
        setIsReconnecting(false);
        setError('Encryption key restore failed - please refresh');
        setView('pin');
        return;
      }
    }

    try {
      await connectWebSocket();
    } catch {
      // onclose handler will schedule next reconnect
      return;
    }

    // Send auth
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN && sharedKeyRef.current) {
      try {
        const encrypted = await encrypt(
          JSON.stringify({ type: 'auth', pin: pinToUse }),
          sharedKeyRef.current
        );
        wsRef.current.send(JSON.stringify(encrypted));
        console.log('[reconnect] Auth sent');
      } catch (err) {
        console.error('[reconnect] Failed to send auth:', err);
        // Will get closed, onclose will retry
      }
    }
  }, [connectWebSocket, restoreSharedKey]);

  // Clean up reconnect timer on unmount
  useEffect(() => {
    return () => {
      if (reconnectTimerRef.current) clearTimeout(reconnectTimerRef.current);
    };
  }, []);

  // Auto-dismiss errors after 8 seconds (unless it's a pairing/key error that needs action)
  useEffect(() => {
    if (!error) return;
    const timer = setTimeout(() => setError(''), 8000);
    return () => clearTimeout(timer);
  }, [error]);

  const handlePinSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!pin || pin.length < 4) {
      setError('PIN must be at least 4 digits');
      return;
    }

    // Cache the PIN for auto-reconnect
    cachedPinRef.current = pin;
    localStorage.setItem('claude-remote-pin', JSON.stringify({ pin, exp: Date.now() + 24 * 60 * 60 * 1000 }));

    setError('');
    await connectAndAuth();
  };

  const handleSend = useCallback(async (text: string) => {
    if (!activeProjectId) {
      setShowProjectPicker(true);
      return;
    }

    if (isStreaming) return;

    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) {
      setError('Not connected - waiting for reconnection...');
      return;
    }

    if (!sharedKeyRef.current) {
      setError('Encryption key missing - please refresh the page');
      return;
    }

    setError('');

    const taskStartTime = Date.now();
    updateProjectState(activeProjectId, state => ({
      ...state,
      messages: [...state.messages, { role: 'user' as const, content: text }],
      isStreaming: true,
      currentThinking: '',
      currentResponse: '',
      currentActivity: [],
      currentTask: text,
      taskStartTime,
    }));

    setStreamingProjectIds(prev => new Set(prev).add(activeProjectId));

    thinkingRefs.current.set(activeProjectId, '');
    responseRefs.current.set(activeProjectId, '');
    activityRefs.current.set(activeProjectId, []);

    try {
      const encrypted = await encrypt(
        JSON.stringify({ type: 'message', text, projectId: activeProjectId }),
        sharedKeyRef.current
      );
      wsRef.current.send(JSON.stringify(encrypted));
    } catch (err) {
      console.error('[send] Failed:', err);
      setError(`Failed to send message: ${err}`);
      setStreamingProjectIds(prev => {
        const next = new Set(prev);
        next.delete(activeProjectId);
        return next;
      });
      updateProjectState(activeProjectId, state => ({
        ...state,
        isStreaming: false,
      }));
    }
  }, [activeProjectId, isStreaming, updateProjectState]);

  const handleCancel = useCallback(async () => {
    if (!activeProjectId) return;

    // Optimistic UI update
    setStreamingProjectIds(prev => {
      const next = new Set(prev);
      next.delete(activeProjectId);
      return next;
    });
    updateProjectState(activeProjectId, state => ({
      ...state,
      isStreaming: false,
    }));

    // Try WebSocket cancel
    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN && sharedKeyRef.current) {
      try {
        const encrypted = await encrypt(
          JSON.stringify({ type: 'cancel', projectId: activeProjectId }),
          sharedKeyRef.current
        );
        wsRef.current.send(JSON.stringify(encrypted));
      } catch (err) {
        console.error('[cancel] WS cancel failed:', err);
      }
    }

    // Also fire HTTP cancel as fallback (fire and forget)
    apiFetch(`/api/projects/${encodeURIComponent(activeProjectId)}/cancel`, { method: 'POST' })
      .catch(err => console.error('[cancel] HTTP cancel failed:', err));
  }, [activeProjectId, updateProjectState]);

  // Handle project selection from picker
  const handleSelectProject = (project: Project) => {
    console.log('Selected project:', project.id);

    // Add to open projects if not already open
    if (!openProjects.find(p => p.id === project.id)) {
      setOpenProjects(prev => [...prev, project]);
      // Initialize empty state for new project
      if (!projectStates.has(project.id)) {
        setProjectStates(prev => {
          const next = new Map(prev);
          next.set(project.id, createEmptyProjectState());
          return next;
        });
      }
      // Fetch conversation history for this project
      fetchProjectConversation(project.id);
    }

    // Set as active
    setActiveProjectId(project.id);
    setShowProjectPicker(false);
  };

  // Handle closing a project tab
  const handleCloseProject = (projectId: string) => {
    setOpenProjects(prev => prev.filter(p => p.id !== projectId));

    // If closing the active project, switch to another or null
    if (activeProjectId === projectId) {
      const remaining = openProjects.filter(p => p.id !== projectId);
      setActiveProjectId(remaining.length > 0 ? remaining[remaining.length - 1].id : null);
    }

    // Clear project state
    setProjectStates(prev => {
      const next = new Map(prev);
      next.delete(projectId);
      return next;
    });
  };

  // Reset stuck state for current project
  const handleReset = () => {
    setError('');
    if (activeProjectId) {
      setStreamingProjectIds(prev => {
        const next = new Set(prev);
        next.delete(activeProjectId);
        return next;
      });
      updateProjectState(activeProjectId, state => ({
        ...state,
        isStreaming: false,
        currentThinking: '',
        currentResponse: '',
        currentActivity: [],
        currentTask: '',
        taskStartTime: null,
      }));
    }
    console.log('State reset by user');
  };

  if (view === 'pairing') {
    return (
      <main className="min-h-screen flex flex-col items-center justify-center bg-[var(--color-bg-primary)] text-[var(--color-text-primary)] p-4">
        <div className="text-center">
          <h1 className="text-2xl font-bold mb-4">{error ? 'Error' : 'Pairing...'}</h1>
          {error ? (
            <>
              <p className="text-red-400 mb-4">{error}</p>
              <a href="/" className="px-6 py-3 bg-[var(--color-accent)] rounded-lg font-semibold hover:bg-[var(--color-accent-hover)] transition-colors inline-block">
                Go to Home
              </a>
            </>
          ) : (
            <p className="text-[var(--color-text-secondary)]">Establishing secure connection</p>
          )}
        </div>
      </main>
    );
  }

  if (view === 'pin') {
    return (
      <main className="min-h-screen flex flex-col items-center justify-center bg-[var(--color-bg-primary)] text-[var(--color-text-primary)] p-4">
        <div className="w-full max-w-xs">
          <h1 className="text-2xl font-bold mb-2 text-center">Enter PIN</h1>
          {error && <p className="text-red-400 text-sm mb-4 text-center">{error}</p>}
          <form onSubmit={handlePinSubmit}>
            <input
              type="password"
              inputMode="numeric"
              pattern="[0-9]*"
              value={pin}
              onChange={(e) => setPin(e.target.value.replace(/\D/g, ''))}
              placeholder="Enter PIN"
              className="w-full p-4 text-2xl text-center bg-[var(--color-bg-secondary)] rounded-lg mb-4 focus:outline-none focus:ring-2 focus:ring-[var(--color-accent)]"
              autoFocus
            />
            <button
              type="submit"
              className="w-full p-4 bg-[var(--color-accent)] rounded-lg font-semibold hover:bg-[var(--color-accent-hover)] transition-colors"
            >
              Unlock
            </button>
          </form>
        </div>
      </main>
    );
  }

  return (
    <main className="h-[100dvh] flex flex-col bg-[var(--color-bg-primary)] text-[var(--color-text-primary)]">
      {/* Project Tabs */}
      <ProjectTabs
        projects={openProjects}
        activeProjectId={activeProjectId}
        streamingProjectIds={streamingProjectIds}
        onSelectProject={setActiveProjectId}
        onCloseProject={handleCloseProject}
        onAddProject={() => setShowProjectPicker(true)}
      />

      {/* Header */}
      <header className="flex items-center justify-between px-4 py-2 border-b border-[var(--color-border-default)] bg-[var(--color-bg-primary)] sticky top-0 z-10">
        <div className="flex items-center gap-3 min-w-0 flex-1">
          <h1 className="text-lg font-semibold truncate">
            {activeProjectId
              ? openProjects.find(p => p.id === activeProjectId)?.name || activeProjectId
              : 'Select a project'}
          </h1>
          <GitStatus projectId={activeProjectId} />
        </div>
        <div className="flex gap-2 shrink-0">
          <button
            type="button"
            onClick={handleReset}
            className="p-2 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors"
            title="Reset stuck state"
            aria-label="Reset"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M4 2a1 1 0 011 1v2.101a7.002 7.002 0 0111.601 2.566 1 1 0 11-1.885.666A5.002 5.002 0 005.999 7H9a1 1 0 010 2H4a1 1 0 01-1-1V3a1 1 0 011-1zm.008 9.057a1 1 0 011.276.61A5.002 5.002 0 0014.001 13H11a1 1 0 110-2h5a1 1 0 011 1v5a1 1 0 11-2 0v-2.101a7.002 7.002 0 01-11.601-2.566 1 1 0 01.61-1.276z" clipRule="evenodd" />
            </svg>
          </button>
          <button
            type="button"
            onClick={clearHistory}
            disabled={isStreaming || !activeProjectId}
            className="p-2 text-[var(--color-text-secondary)] hover:text-[var(--color-text-primary)] transition-colors disabled:opacity-50"
            title="Clear conversation history"
            aria-label="Clear history"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
          </button>
        </div>
      </header>

      {/* Reconnecting banner */}
      {isReconnecting && (
        <div className="flex items-center justify-center gap-2 px-4 py-2 bg-yellow-900/80 border-b border-yellow-700 text-yellow-200 text-sm">
          <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24" fill="none">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
          </svg>
          <span>Reconnecting{reconnectAttempt > 1 ? ` (attempt ${reconnectAttempt})` : ''}...</span>
          <button
            onClick={() => {
              if (reconnectTimerRef.current) clearTimeout(reconnectTimerRef.current);
              setIsReconnecting(false);
              setReconnectAttempt(0);
              reconnectAttemptRef.current = 0;
              cachedPinRef.current = null;
              localStorage.removeItem('claude-remote-pin');
              setView('pin');
            }}
            className="ml-2 px-2 py-0.5 text-xs bg-yellow-800 hover:bg-yellow-700 rounded transition-colors"
          >
            Use PIN
          </button>
        </div>
      )}

      {/* Project Picker Modal */}
      <ProjectPicker
        isOpen={showProjectPicker}
        onClose={() => setShowProjectPicker(false)}
        onSelect={handleSelectProject}
        openProjectIds={openProjectIds}
      />

      {/* Messages */}
      <div className="flex-1 overflow-y-auto px-3 py-4 space-y-3 sm:px-4 sm:space-y-4">
        {!activeProjectId ? (
          <div className="flex flex-col items-center justify-center h-full text-center">
            <div className="p-6 rounded-2xl bg-[var(--color-bg-secondary)]/50">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-12 w-12 mx-auto mb-4 text-[var(--color-text-tertiary)]" viewBox="0 0 20 20" fill="currentColor">
                <path d="M2 6a2 2 0 012-2h5l2 2h5a2 2 0 012 2v6a2 2 0 01-2 2H4a2 2 0 01-2-2V6z" />
              </svg>
              <p className="text-[var(--color-text-secondary)] mb-4">Select a project to start chatting</p>
              <button
                onClick={() => setShowProjectPicker(true)}
                className="px-4 py-2 bg-[var(--color-accent)] rounded-lg hover:bg-[var(--color-accent-hover)] transition-colors"
              >
                Open Project
              </button>
            </div>
          </div>
        ) : (
          <div className="space-y-4">
            {messages.map((msg, i) => (
              <div key={i}>
                {msg.role === 'user' ? (
                  // User message - compact bubble on the right
                  <div className="flex justify-end">
                    <div className="max-w-[90%] sm:max-w-[85%]">
                      <div className="rounded-2xl px-4 py-3 bg-[var(--color-accent)]">
                        <div className="whitespace-pre-wrap break-words">{msg.content}</div>
                      </div>
                    </div>
                  </div>
                ) : (
                  // Assistant message - full width response card
                  <StreamingResponse
                    thinking={msg.thinking}
                    activity={msg.activity}
                    content={msg.content}
                    task={msg.task}
                    startedAt={msg.startedAt}
                    completedAt={msg.completedAt}
                  />
                )}
              </div>
            ))}

            {/* Streaming response */}
            {isStreaming && (
              <StreamingResponse
                thinking={currentThinking}
                activity={currentActivity}
                content={currentResponse}
                task={currentTask}
                startedAt={taskStartTime ? new Date(taskStartTime).toISOString() : undefined}
                isStreaming
              />
            )}

            {messages.length === 0 && !isStreaming && (
              <div className="flex flex-col items-center justify-center h-full text-center">
                <p className="text-[var(--color-text-tertiary)]">Start a conversation with Claude in this project</p>
              </div>
            )}
          </div>
        )}

        <div ref={messagesEndRef} />
      </div>

      {/* Input area */}
      <div className="border-t border-[var(--color-border-default)] bg-[var(--color-bg-primary)] px-3 py-3 pb-[max(0.75rem,env(safe-area-inset-bottom))] sm:px-4 sm:py-4">
        {error && !isReconnecting && (
          <div className="bg-red-900/80 border border-red-500 rounded-xl p-3 mb-3 flex items-start gap-2">
            <div className="flex-1 min-w-0">
              <p className="text-red-300 text-sm break-words">{error}</p>
            </div>
            <button
              onClick={() => setError('')}
              className="shrink-0 text-red-400 hover:text-red-200 transition-colors"
              aria-label="Dismiss error"
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd" />
              </svg>
            </button>
          </div>
        )}
        <ChatInput
          isStreaming={isStreaming}
          onSend={handleSend}
          onCancel={handleCancel}
        />
      </div>
    </main>
  );
}



#########################
### client/src/pages/Home.tsx
import { useState, useEffect, useRef } from 'react';
import type { PairInfo } from '../App';
import { apiFetch } from '../lib/api';

interface Props {
  onNavigate: (route: 'home' | 'chat' | 'pair') => void;
  pairInfo?: PairInfo | null;
}

interface DeviceInfo {
  id: string;
  createdAt: string;
}

interface Status {
  paired: boolean;
  devices: DeviceInfo[];
  deviceCount: number;
  pairingUrl: string | null;
}

// Crypto helpers (same as Chat.tsx)
async function generateKeyPair(): Promise<CryptoKeyPair> {
  return crypto.subtle.generateKey(
    { name: 'ECDH', namedCurve: 'P-256' },
    true,
    ['deriveBits']
  );
}

async function exportPublicKey(key: CryptoKey): Promise<string> {
  const raw = await crypto.subtle.exportKey('raw', key);
  return btoa(String.fromCharCode(...new Uint8Array(raw)));
}

async function importPublicKey(base64: string): Promise<CryptoKey> {
  const raw = Uint8Array.from(atob(base64), c => c.charCodeAt(0));
  return crypto.subtle.importKey(
    'raw',
    raw,
    { name: 'ECDH', namedCurve: 'P-256' },
    true,
    []
  );
}

async function deriveSharedSecret(privateKey: CryptoKey, publicKey: CryptoKey): Promise<CryptoKey> {
  const bits = await crypto.subtle.deriveBits(
    { name: 'ECDH', public: publicKey },
    privateKey,
    256
  );
  const hash = await crypto.subtle.digest('SHA-256', bits);
  return crypto.subtle.importKey('raw', hash, { name: 'AES-GCM' }, true, ['encrypt', 'decrypt']);
}

export default function Home({ onNavigate, pairInfo }: Props) {
  const [status, setStatus] = useState<Status | null>(null);
  const [unpairing, setUnpairing] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Pairing state
  const [pairingUrl, setPairingUrl] = useState('');
  const [isPairing, setIsPairing] = useState(false);
  const [pairingLog, setPairingLog] = useState<string[]>([]);
  const autoPairingStarted = useRef(false);

  const addLog = (msg: string) => {
    console.log(msg);
    setPairingLog(prev => [...prev, msg]);
  };

  const fetchStatus = async () => {
    try {
      const res = await fetch('/api/status');
      if (!res.ok) throw new Error('Failed to fetch status');
      const data = await res.json();
      setStatus(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error');
    }
  };

  useEffect(() => {
    fetchStatus();
  }, []);

  // Auto-pair if pairInfo is provided from URL
  useEffect(() => {
    if (pairInfo && !autoPairingStarted.current) {
      autoPairingStarted.current = true;
      doPairingWithInfo(pairInfo.serverUrl, pairInfo.token);
    }
  }, [pairInfo]);

  const handleUnpair = async () => {
    setUnpairing(true);
    try {
      const res = await apiFetch('/api/unpair', { method: 'POST' });
      if (res.ok) {
        localStorage.removeItem('claude-remote-paired');
        localStorage.removeItem('claude-remote-device-id');
        localStorage.removeItem('claude-remote-private-key');
        localStorage.removeItem('claude-remote-server-public-key');
        await fetchStatus();
      }
    } catch {
      setError('Failed to unpair');
    } finally {
      setUnpairing(false);
    }
  };

  // Parse pairing URL and extract server + token
  // Supports both formats:
  // - New: https://client/pair?server=https://server&token=TOKEN
  // - Old: https://server/pair/TOKEN
  const parseUrl = (url: string): { serverUrl: string; token: string } | null => {
    try {
      const uri = new URL(url.trim());
      const params = new URLSearchParams(uri.search);
      const segments = uri.pathname.split('/').filter(Boolean);

      // New format: /pair?server=...&token=...
      const serverParam = params.get('server');
      const tokenParam = params.get('token');
      if (serverParam && tokenParam) {
        return { serverUrl: serverParam, token: tokenParam };
      }

      // Old format: /pair/TOKEN (server is the URL host)
      if (segments.length >= 2 && segments[0] === 'pair') {
        const token = segments[1];
        const serverUrl = `${uri.protocol}//${uri.host}`;
        return { serverUrl, token };
      }

      return null;
    } catch {
      return null;
    }
  };

  const doPairing = () => {
    const parsed = parseUrl(pairingUrl);
    if (!parsed) {
      setError('Invalid URL. Expected format: https://server/pair?server=...&token=... or https://server/pair/TOKEN');
      return;
    }
    doPairingWithInfo(parsed.serverUrl, parsed.token);
  };

  const doPairingWithInfo = async (serverUrl: string, token: string) => {
    setPairingLog([]);
    setError(null);
    addLog(`Server: ${serverUrl}`);
    addLog(`Token: ${token}`);

    setIsPairing(true);
    try {
      // Step 1: Generate keypair
      addLog('Generating keypair...');
      const keyPair = await generateKeyPair();
      const clientPublicKey = await exportPublicKey(keyPair.publicKey);
      const privateKeyJwk = await crypto.subtle.exportKey('jwk', keyPair.privateKey);
      addLog('Keypair generated');

      // Step 2: GET server public key
      addLog(`GET ${serverUrl}/pair/${token}`);
      const getRes = await fetch(`${serverUrl}/pair/${token}`);
      if (!getRes.ok) {
        const data = await getRes.json().catch(() => ({}));
        throw new Error(`Failed to get server key: ${data.error || getRes.status}`);
      }
      const { serverPublicKey } = await getRes.json();
      if (!serverPublicKey) {
        throw new Error('Server returned empty public key');
      }
      addLog('Got server public key');

      // Step 3: POST client public key
      addLog(`POST ${serverUrl}/pair/${token}`);
      const postRes = await fetch(`${serverUrl}/pair/${token}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ clientPublicKey }),
      });
      if (!postRes.ok) {
        const data = await postRes.json().catch(() => ({}));
        throw new Error(`Failed to complete pairing: ${data.error || postRes.status}`);
      }
      const { deviceId } = await postRes.json();
      if (!deviceId) {
        throw new Error('Server returned empty device ID');
      }
      addLog(`Device ID: ${deviceId}`);

      // Step 4: Derive shared secret and store
      addLog('Deriving shared secret...');
      const serverKey = await importPublicKey(serverPublicKey);
      const sharedSecret = await deriveSharedSecret(keyPair.privateKey, serverKey);
      const sharedSecretJwk = await crypto.subtle.exportKey('jwk', sharedSecret);

      // Store credentials
      localStorage.setItem('claude-remote-paired', 'true');
      localStorage.setItem('claude-remote-device-id', deviceId);
      localStorage.setItem('claude-remote-private-key', JSON.stringify(privateKeyJwk));
      localStorage.setItem('claude-remote-server-public-key', serverPublicKey);
      localStorage.setItem('claude-remote-shared-secret', JSON.stringify(sharedSecretJwk));
      localStorage.setItem('claude-remote-server-url', serverUrl);

      addLog('Pairing complete!');

      // Navigate to chat
      setTimeout(() => {
        onNavigate('chat');
      }, 500);

    } catch (err) {
      const msg = err instanceof Error ? err.message : 'Unknown error';
      addLog(`ERROR: ${msg}`);
      setError(msg);
    } finally {
      setIsPairing(false);
    }
  };

  if (error && !pairingLog.length) {
    return (
      <main className="min-h-screen flex flex-col items-center justify-center bg-[var(--color-bg-primary)] text-[var(--color-text-primary)] p-4">
        <div className="text-center">
          <h1 className="text-2xl font-bold mb-4">Error</h1>
          <p className="text-red-400">{error}</p>
        </div>
      </main>
    );
  }

  if (!status) {
    return (
      <main className="min-h-screen flex flex-col items-center justify-center bg-[var(--color-bg-primary)] text-[var(--color-text-primary)] p-4">
        <div className="text-center">
          <p className="text-[var(--color-text-secondary)]">Loading...</p>
        </div>
      </main>
    );
  }

  const hasBrowserCredentials = !!localStorage.getItem('claude-remote-paired');
  const myDeviceId = localStorage.getItem('claude-remote-device-id');

  // This browser is paired - show chat link
  if (hasBrowserCredentials && myDeviceId) {
    return (
      <main className="min-h-screen flex flex-col items-center justify-center bg-[var(--color-bg-primary)] text-[var(--color-text-primary)] p-4">
        <div className="text-center">
          <h1 className="text-2xl font-bold mb-2">Claude Remote</h1>
          <p className="text-[var(--color-text-secondary)] mb-4">Device paired and ready.</p>
          <p className="text-sm text-[var(--color-text-tertiary)] mb-2">This device: {myDeviceId}</p>
          <p className="text-sm text-[var(--color-text-tertiary)] mb-6">Total devices: {status.deviceCount}</p>
          <div className="flex flex-col gap-3">
            <button
              onClick={() => onNavigate('chat')}
              className="px-6 py-3 bg-[var(--color-accent)] rounded-lg font-semibold hover:bg-[var(--color-accent-hover)] transition-colors text-center"
            >
              Open Chat
            </button>
            <button
              onClick={handleUnpair}
              disabled={unpairing}
              className="px-6 py-3 bg-[var(--color-bg-hover)] rounded-lg font-semibold hover:bg-[var(--color-border-emphasis)] transition-colors disabled:opacity-50"
            >
              {unpairing ? 'Resetting...' : 'Unpair All & Reset'}
            </button>
          </div>
        </div>
      </main>
    );
  }

  // Not paired - show pairing input
  return (
    <main className="min-h-screen flex flex-col items-center justify-center bg-[var(--color-bg-primary)] text-[var(--color-text-primary)] p-4">
      <div className="w-full max-w-md">
        <h1 className="text-2xl font-bold mb-2 text-center">Claude Remote</h1>
        <p className="text-[var(--color-text-secondary)] mb-6 text-center">
          Scan or paste your pairing link
        </p>

        {error && (
          <div className="bg-red-900/50 border border-red-500 rounded-lg p-3 mb-4">
            <p className="text-red-400 text-sm">{error}</p>
          </div>
        )}

        <div className="space-y-4">
          <input
            type="text"
            value={pairingUrl}
            onChange={(e) => setPairingUrl(e.target.value)}
            placeholder="https://server/pair/token..."
            className="w-full px-4 py-3 bg-[var(--color-bg-secondary)] border border-[var(--color-border-default)] rounded-lg text-[var(--color-text-primary)] placeholder-[var(--color-text-tertiary)] focus:outline-none focus:border-[var(--color-accent)]"
          />

          <div className="flex gap-2">
            <button
              onClick={async () => {
                try {
                  const text = await navigator.clipboard.readText();
                  setPairingUrl(text);
                } catch {
                  setError('Failed to read clipboard');
                }
              }}
              className="flex-1 px-4 py-3 bg-[var(--color-bg-hover)] rounded-lg font-semibold hover:bg-[var(--color-border-emphasis)] transition-colors"
            >
              Paste
            </button>
            <button
              onClick={doPairing}
              disabled={isPairing || !pairingUrl.trim()}
              className="flex-1 px-4 py-3 bg-[var(--color-accent)] rounded-lg font-semibold hover:bg-[var(--color-accent-hover)] transition-colors disabled:opacity-50"
            >
              {isPairing ? 'Pairing...' : 'Pair'}
            </button>
          </div>
        </div>

        {pairingLog.length > 0 && (
          <div className="mt-6 bg-[var(--color-bg-secondary)] rounded-lg p-4">
            <p className="text-[var(--color-text-secondary)] text-sm mb-2">Log:</p>
            <div className="font-mono text-xs text-green-400 space-y-1">
              {pairingLog.map((log, i) => (
                <p key={i}>{log}</p>
              ))}
            </div>
          </div>
        )}
      </div>
    </main>
  );
}



#########################
### eslint.config.mjs
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;



#########################
### index.html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#1a1a1a" />
    <title>Claude Remote</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,300;0,400;0,500;0,600;1,400&display=swap" rel="stylesheet" />
  </head>
  <body class="antialiased">
    <div id="root"></div>
    <script type="module" src="/client/src/main.tsx"></script>
  </body>
</html>



#########################
### package.json
{
  "name": "claude-remote",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "concurrently -n server,client -c blue,green \"tsx --watch server.ts 2>&1 | tee logs/server.log\" \"vite 2>&1 | tee logs/client.log\"",
    "dev:server": "tsx --watch server.ts 2>&1 | tee logs/server.log",
    "dev:client": "vite 2>&1 | tee logs/client.log",
    "build": "vite build",
    "build:all": "pnpm build",
    "start": "NODE_ENV=production tsx server.ts 2>&1 | tee logs/server.log",
    "prod": "pnpm build && concurrently -n server,client -c blue,green \"NODE_ENV=production tsx server.ts\" \"vite preview --port 5173\"",
    "lint": "eslint",
    "logs:server": "tail -f logs/server.log",
    "logs:client": "tail -f logs/client.log",
    "reload": "touch server.ts"
  },
  "dependencies": {
    "argon2": "^0.44.0",
    "dotenv": "^17.2.3",
    "qrcode-terminal": "^0.12.0",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "ws": "^8.19.0"
  },
  "devDependencies": {
    "@tailwindcss/vite": "^4.1.18",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/ws": "^8.18.1",
    "@vitejs/plugin-react": "^5.1.2",
    "concurrently": "^9.2.1",
    "eslint": "^9",
    "tailwindcss": "^4.1.18",
    "tsx": "^4.21.0",
    "typescript": "^5",
    "vite": "^7.3.1"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "argon2",
      "esbuild"
    ]
  }
}



#########################
### pnpm-workspace.yaml
onlyBuiltDependencies:
  - argon2
  - esbuild
  - sharp
  - unrs-resolver



#########################
### public/file.svg
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>


#########################
### public/globe.svg
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>


#########################
### public/next.svg
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>


#########################
### public/vercel.svg
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>


#########################
### public/window.svg
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>


#########################
### server.ts
import { config } from 'dotenv';
config({ path: '.env.local' });

import { createServer, IncomingMessage, ServerResponse } from 'http';
import { parse } from 'url';
import { WebSocketServer, WebSocket } from 'ws';
import { randomBytes, timingSafeEqual } from 'crypto';
import { readFileSync, existsSync, appendFileSync, writeFileSync } from 'fs';
import { execSync } from 'child_process';
import { homedir } from 'os';
import qrcode from 'qrcode-terminal';
import { join, resolve } from 'path';
import {
  generateKeyPair,
  deriveSharedSecret,
  encrypt,
  decrypt,
  EncryptedData,
} from './src/lib/crypto';
import {
  loadDevices,
  addDevice,
  removeDevice,
  loadServerState,
  saveServerState,
  verifyPin,
  hashPin,
  loadConversation,
  addMessage,
  clearConversation,
  getClaudeSessionId,
  saveClaudeSessionId,
  Device,
  ServerState,
  Message,
  ToolActivity,
  OutputChunk,
  // Project support
  validateProjectId,
  listProjects,
  getProject,
  loadProjectConversation,
  addProjectMessage,
  clearProjectConversation,
  getProjectSessionId,
  saveProjectSessionId,
} from './src/lib/store';
import { spawnClaude, ClaudeEvent } from './src/lib/claude';

// Track active Claude processes per device per project
// Key format: `${deviceId}:${projectId}` or just `${deviceId}` for legacy
const activeJobs: Map<string, AbortController> = new Map();
// Track connected WebSockets per device
const connectedClients: Map<string, WebSocket> = new Map();
// Track which projects have already sent the "rejoined" context note this server boot
const rejoinNoteSent: Set<string> = new Set();

// Rate limiting for auth attempts per IP
const AUTH_MAX_ATTEMPTS = 5;
const AUTH_WINDOW_MS = 60_000; // 1 minute
const authAttempts: Map<string, { count: number; resetAt: number }> = new Map();

function checkAuthRateLimit(ip: string): boolean {
  const now = Date.now();
  const entry = authAttempts.get(ip);
  if (!entry || now >= entry.resetAt) {
    authAttempts.set(ip, { count: 1, resetAt: now + AUTH_WINDOW_MS });
    return true;
  }
  entry.count++;
  return entry.count <= AUTH_MAX_ATTEMPTS;
}

// Broadcast reload message to all connected clients (for dev hot reload)
function broadcastReload() {
  console.log('[dev] Broadcasting reload to', connectedClients.size, 'clients');
  const devices = loadDevices();
  for (const [deviceId, ws] of connectedClients.entries()) {
    if (ws.readyState === WebSocket.OPEN) {
      const device = devices.find(d => d.id === deviceId);
      if (device) {
        const encrypted = encrypt(JSON.stringify({ type: 'reload' }), device.sharedSecret);
        ws.send(JSON.stringify(encrypted));
        console.log(`[dev] Sent reload to device ${deviceId}`);
      }
    }
  }
}

// Broadcast an event to all connected clients except the sender
function broadcastToOthers(excludeDeviceId: string, event: object) {
  for (const [connDeviceId, connWs] of connectedClients.entries()) {
    if (connDeviceId === excludeDeviceId) continue;
    if (connWs.readyState !== WebSocket.OPEN) continue;
    const connDevice = devices.find(d => d.id === connDeviceId);
    if (connDevice) {
      const encrypted = encrypt(JSON.stringify(event), connDevice.sharedSecret);
      connWs.send(JSON.stringify(encrypted));
    }
  }
}

// Helper to create job key
function jobKey(deviceId: string, projectId?: string): string {
  return projectId ? `${deviceId}:${projectId}` : deviceId;
}

// Events file path
const configDir = join(homedir(), '.config', 'claude-remote');
const eventsFile = join(configDir, 'events.jsonl');

function appendEvent(deviceId: string, event: ClaudeEvent) {
  const line = JSON.stringify({ deviceId, event, ts: Date.now() }) + '\n';
  appendFileSync(eventsFile, line);
}

// Persist last flushed timestamp per device to disk
const lastFlushedFile = join(configDir, 'last-flushed.json');

function loadLastFlushedTs(): Record<string, number> {
  try {
    if (!existsSync(lastFlushedFile)) return {};
    return JSON.parse(readFileSync(lastFlushedFile, 'utf-8'));
  } catch { return {}; }
}

function saveLastFlushedTs(deviceId: string, ts: number) {
  const data = loadLastFlushedTs();
  data[deviceId] = ts;
  writeFileSync(lastFlushedFile, JSON.stringify(data, null, 2));
}

function loadPendingEvents(deviceId: string): ClaudeEvent[] {
  if (!existsSync(eventsFile)) return [];
  const lines = readFileSync(eventsFile, 'utf-8').trim().split('\n').filter(Boolean);
  const events: ClaudeEvent[] = [];
  const lastTs = loadLastFlushedTs()[deviceId] || 0;
  let maxTs = lastTs;
  for (const line of lines) {
    try {
      const { deviceId: did, event, ts } = JSON.parse(line);
      if (did === deviceId && ts > lastTs) {
        events.push(event);
        if (ts > maxTs) maxTs = ts;
      }
    } catch {}
  }
  if (maxTs > lastTs) saveLastFlushedTs(deviceId, maxTs);
  return events;
}

function clearPendingEvents(deviceId: string) {
  if (!existsSync(eventsFile)) return;
  const lines = readFileSync(eventsFile, 'utf-8').trim().split('\n').filter(Boolean);
  const remaining = lines.filter(line => {
    try {
      const { deviceId: did } = JSON.parse(line);
      return did !== deviceId;
    } catch { return true; }
  });
  writeFileSync(eventsFile, remaining.join('\n') + (remaining.length ? '\n' : ''));
}

// Partial response persistence (survives crashes)
const partialResponseFile = join(configDir, 'partial-responses.json');

interface PartialResponse {
  text: string;
  thinking: string;
  activity: ToolActivity[];
  updatedAt: number;
}

function loadPartialResponses(): Record<string, PartialResponse> {
  try {
    if (!existsSync(partialResponseFile)) return {};
    return JSON.parse(readFileSync(partialResponseFile, 'utf-8'));
  } catch { return {}; }
}

// Debounced partial response saving â€” at most once per second
const pendingPartials: Map<string, { text: string; thinking: string; activity: ToolActivity[] }> = new Map();
let partialSaveTimer: ReturnType<typeof setTimeout> | null = null;

function flushPartialResponses() {
  if (pendingPartials.size === 0) return;
  const data = loadPartialResponses();
  for (const [key, partial] of pendingPartials) {
    data[key] = { ...partial, updatedAt: Date.now() };
  }
  pendingPartials.clear();
  writeFileSync(partialResponseFile, JSON.stringify(data, null, 2));
}

function savePartialResponse(deviceId: string, text: string, thinking: string, activity: ToolActivity[] = []) {
  pendingPartials.set(deviceId, { text, thinking, activity });
  if (!partialSaveTimer) {
    partialSaveTimer = setTimeout(() => {
      partialSaveTimer = null;
      flushPartialResponses();
    }, 1000);
  }
}

function clearPartialResponse(deviceId: string) {
  const data = loadPartialResponses();
  delete data[deviceId];
  writeFileSync(partialResponseFile, JSON.stringify(data, null, 2));
}

function recoverPartialResponses() {
  // On startup, check for partial responses and save them as messages
  const partials = loadPartialResponses();
  for (const [deviceId, partial] of Object.entries(partials)) {
    if (partial.text || partial.thinking || partial.activity.length > 0) {
      console.log(`[recovery] Found partial response for device ${deviceId}, saving...`);
      addMessage({
        role: 'assistant',
        content: partial.text + '\n\n[Response interrupted - server restarted]',
        thinking: partial.thinking || undefined,
        activity: partial.activity.length > 0 ? partial.activity : undefined,
        timestamp: new Date(partial.updatedAt).toISOString(),
      });
    }
  }
  // Clear all partials after recovery
  writeFileSync(partialResponseFile, '{}');
}

const port = parseInt(process.env.PORT || '6767', 10);
const clientUrl = process.env.CLIENT_URL || `http://localhost:5173`;
const serverUrl = process.env.SERVER_URL || `http://localhost:${port}`;

const PIN = process.env.CLAUDE_REMOTE_PIN;
if (!PIN) {
  console.error('CLAUDE_REMOTE_PIN environment variable is required');
  process.exit(1);
}

let pinHash: string;
let serverState: ServerState;
let devices: Device[] = [];

function initializeServer() {
  devices = loadDevices();
  const existingState = loadServerState();

  if (existingState) {
    // Always keep pairing token active for multi-device support
    if (!existingState.pairingToken) {
      existingState.pairingToken = randomBytes(16).toString('hex');
    }
    serverState = existingState;
  } else {
    const keyPair = generateKeyPair();
    serverState = {
      privateKey: keyPair.privateKey,
      publicKey: keyPair.publicKey,
      pairingToken: randomBytes(16).toString('hex'),
    };
  }
  saveServerState(serverState);
}

function reloadState() {
  devices = loadDevices();
  const existingState = loadServerState();
  if (existingState) {
    serverState = existingState;
  }
}

// Try all devices to avoid timing side-channel leaking which device index matched
function findDeviceByDecryption(encrypted: EncryptedData): Device | null {
  let matched: Device | null = null;
  for (const device of devices) {
    try {
      decrypt(encrypted, device.sharedSecret);
      matched = device;
    } catch {
      // Try next device
    }
  }
  return matched;
}

function json(res: ServerResponse, data: object, status = 200) {
  res.writeHead(status, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify(data));
}

// API authentication: compare PIN using timing-safe comparison
function checkApiAuth(req: IncomingMessage, res: ServerResponse): boolean {
  const auth = req.headers['authorization'];
  if (!auth || !auth.startsWith('Bearer ')) {
    json(res, { error: 'Unauthorized' }, 401);
    return false;
  }
  const providedPin = auth.slice(7);
  // Use timingSafeEqual to prevent timing attacks
  const pinBuf = Buffer.from(PIN!);
  const providedBuf = Buffer.from(providedPin);
  if (pinBuf.length !== providedBuf.length || !timingSafeEqual(pinBuf, providedBuf)) {
    json(res, { error: 'Unauthorized' }, 401);
    return false;
  }
  return true;
}

async function handleRequest(req: IncomingMessage, res: ServerResponse) {
  const { pathname } = parse(req.url || '', true);
  const method = req.method || 'GET';

  // CORS: restrict to known origins
  const allowedOrigins = [clientUrl, 'https://ai.pond.audio'];
  const origin = req.headers['origin'];
  if (origin && allowedOrigins.includes(origin)) {
    res.setHeader('Access-Control-Allow-Origin', origin);
    res.setHeader('Vary', 'Origin');
  }
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, DELETE, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (method === 'OPTIONS') {
    res.writeHead(204);
    res.end();
    return;
  }

  // Auth gate: all /api/ routes require PIN auth, except /api/status (limited info without auth)
  if (pathname?.startsWith('/api/') && pathname !== '/api/status') {
    if (!checkApiAuth(req, res)) return;
  }

  // API: Status - limited info without auth, full info with auth
  if (pathname === '/api/status' && method === 'GET') {
    reloadState();
    // Check if caller is authenticated (optional)
    const auth = req.headers['authorization'];
    const isAuthed = (() => {
      if (!auth || !auth.startsWith('Bearer ')) return false;
      const providedPin = auth.slice(7);
      const pinBuf = Buffer.from(PIN!);
      const providedBuf = Buffer.from(providedPin);
      return pinBuf.length === providedBuf.length && timingSafeEqual(pinBuf, providedBuf);
    })();

    if (isAuthed) {
      return json(res, {
        paired: devices.length > 0,
        devices: devices.map(d => ({ id: d.id, createdAt: d.createdAt })),
        deviceCount: devices.length,
        pairingUrl: serverState.pairingToken ? `${clientUrl}/pair?server=${encodeURIComponent(serverUrl)}&token=${serverState.pairingToken}` : null,
      });
    }

    // Unauthenticated: limited info only
    return json(res, {
      paired: devices.length > 0,
      deviceCount: devices.length,
    });
  }

  // API: Generate new pairing token (invalidates previous one)
  if (pathname === '/api/new-pair-token' && method === 'POST') {
    reloadState();
    serverState.pairingToken = randomBytes(16).toString('hex');
    saveServerState(serverState);
    const pairUrl = `${clientUrl}/pair?server=${encodeURIComponent(serverUrl)}&token=${serverState.pairingToken}`;
    console.log(`> New pairing token generated`);
    console.log(`> URL: ${pairUrl}`);
    console.log('');
    qrcode.generate(pairUrl, { small: true });
    return json(res, {
      pairingUrl: pairUrl,
      token: serverState.pairingToken
    });
  }

  // API: Dev reload - broadcasts reload message to all connected clients
  if (pathname === '/api/dev/reload' && method === 'POST') {
    broadcastReload();
    return json(res, { ok: true, clients: connectedClients.size });
  }

  // API: Dev full reload - triggers Flutter hot restart then broadcasts reload
  if (pathname === '/api/dev/full-reload' && method === 'POST') {
    try {
      // Send SIGUSR2 to Flutter process for hot restart
      const pidFile = join(process.cwd(), 'logs', 'flutter.pid');
      if (existsSync(pidFile)) {
        const pid = readFileSync(pidFile, 'utf-8').trim();
        process.kill(parseInt(pid), 'SIGUSR2');
        console.log('[dev] Sent SIGUSR2 to Flutter process', pid);
      }
      // Wait for Flutter to rebuild, then broadcast reload
      setTimeout(() => {
        broadcastReload();
      }, 2000);
      return json(res, { ok: true, message: 'Flutter restart triggered, reload will broadcast in 2s' });
    } catch (e) {
      console.error('[dev] Full reload failed:', e);
      return json(res, { ok: false, error: String(e) }, 500);
    }
  }

  // API: Get conversation history
  if (pathname === '/api/conversation' && method === 'GET') {
    const conversation = loadConversation();
    console.log('[api] Returning conversation with', conversation.messages.length, 'messages');
    return json(res, conversation);
  }

  // API: Clear conversation
  if (pathname === '/api/conversation' && method === 'DELETE') {
    clearConversation();
    console.log('[api] Conversation cleared');
    return json(res, { success: true });
  }

  // API: List available projects
  if (pathname === '/api/projects' && method === 'GET') {
    const projects = listProjects();
    console.log('[api] Returning', projects.length, 'projects');
    return json(res, { projects });
  }

  // API: Get project conversation history
  if (pathname?.startsWith('/api/projects/') && pathname.endsWith('/conversation') && method === 'GET') {
    const projectId = decodeURIComponent(pathname.split('/api/projects/')[1].replace('/conversation', ''));
    if (!validateProjectId(projectId)) return json(res, { error: 'Invalid project ID' }, 400);
    const project = getProject(projectId);
    if (!project) {
      return json(res, { error: 'Project not found' }, 404);
    }
    const conversation = loadProjectConversation(projectId);
    console.log(`[api] Returning project ${projectId} conversation with`, conversation.messages.length, 'messages');
    return json(res, conversation);
  }

  // API: Clear project conversation
  if (pathname?.startsWith('/api/projects/') && pathname.endsWith('/conversation') && method === 'DELETE') {
    const projectId = decodeURIComponent(pathname.split('/api/projects/')[1].replace('/conversation', ''));
    if (!validateProjectId(projectId)) return json(res, { error: 'Invalid project ID' }, 400);
    const project = getProject(projectId);
    if (!project) {
      return json(res, { error: 'Project not found' }, 404);
    }
    clearProjectConversation(projectId);
    console.log(`[api] Project ${projectId} conversation cleared`);
    return json(res, { success: true });
  }

  // API: Get streaming state for a project (used on reconnect to restore UI state)
  if (pathname?.startsWith('/api/projects/') && pathname.endsWith('/streaming') && method === 'GET') {
    const projectId = decodeURIComponent(pathname.split('/api/projects/')[1].replace('/streaming', ''));
    if (!validateProjectId(projectId)) return json(res, { error: 'Invalid project ID' }, 400);

    // Check if there's an active job for any device on this project
    let isStreaming = false;
    let streamingDeviceKey: string | null = null;
    for (const key of activeJobs.keys()) {
      if (key.endsWith(`:${projectId}`)) {
        isStreaming = true;
        streamingDeviceKey = key;
        break;
      }
    }

    // Get partial response if streaming
    let partialResponse: PartialResponse | null = null;
    if (streamingDeviceKey) {
      const partials = loadPartialResponses();
      partialResponse = partials[streamingDeviceKey] || null;
    }

    console.log(`[api] Streaming state for ${projectId}: isStreaming=${isStreaming}`);
    return json(res, {
      isStreaming,
      partial: partialResponse ? {
        text: partialResponse.text,
        thinking: partialResponse.thinking,
        activity: partialResponse.activity,
      } : null,
    });
  }

  // API: Cancel task for a project (HTTP fallback for unreliable WebSocket)
  if (pathname?.startsWith('/api/projects/') && pathname.endsWith('/cancel') && method === 'POST') {
    const projectId = decodeURIComponent(pathname.split('/api/projects/')[1].replace('/cancel', ''));
    if (!validateProjectId(projectId)) return json(res, { error: 'Invalid project ID' }, 400);
    console.log(`[api] HTTP cancel requested for project: ${projectId}`);

    // Find and abort all active jobs for this project (any device)
    let cancelled = 0;
    for (const [key, controller] of activeJobs.entries()) {
      if (key.endsWith(`:${projectId}`)) {
        console.log(`[api] Aborting job: ${key}`);
        controller.abort();
        activeJobs.delete(key);
        cancelled++;
      }
    }

    return json(res, { ok: true, cancelled });
  }

  // API: Get git status for a project
  if (pathname?.startsWith('/api/projects/') && pathname.endsWith('/git') && method === 'GET') {
    const projectId = decodeURIComponent(pathname.split('/api/projects/')[1].replace('/git', ''));
    if (!validateProjectId(projectId)) return json(res, { error: 'Invalid project ID' }, 400);
    const project = getProject(projectId);
    if (!project) {
      return json(res, { error: 'Project not found' }, 404);
    }

    try {
      // Get current branch
      const branch = execSync('git rev-parse --abbrev-ref HEAD', {
        cwd: project.path,
        encoding: 'utf-8',
        timeout: 5000,
      }).trim();

      // Check if working directory is dirty
      const status = execSync('git status --porcelain', {
        cwd: project.path,
        encoding: 'utf-8',
        timeout: 5000,
      }).trim();
      const isDirty = status.length > 0;

      // Parse changed files
      const changedFiles = status ? status.split('\n').length : 0;
      const files = status ? status.split('\n').map(line => {
        // Porcelain format: XY PATH (2 status chars + space + path)
        const match = line.match(/^(..) (.+)$/);
        return match
          ? { status: match[1].trim(), path: match[2] }
          : { status: '?', path: line.trim() };
      }) : [];

      // Get ahead/behind counts (may fail if no upstream)
      let ahead = 0;
      let behind = 0;
      try {
        const counts = execSync('git rev-list --left-right --count HEAD...@{upstream}', {
          cwd: project.path,
          encoding: 'utf-8',
          timeout: 5000,
        }).trim().split('\t');
        ahead = parseInt(counts[0], 10) || 0;
        behind = parseInt(counts[1], 10) || 0;
      } catch {
        // No upstream configured, ignore
      }

      console.log(`[api] Git status for ${projectId}: ${branch} ${isDirty ? '(dirty)' : '(clean)'}`);
      return json(res, {
        branch,
        isDirty,
        changedFiles,
        files,
        ahead,
        behind,
      });
    } catch (err) {
      // Not a git repo or git not available
      console.log(`[api] Git status failed for ${projectId}:`, err);
      return json(res, { error: 'Not a git repository' }, 400);
    }
  }

  // API: Pair GET - get server public key
  if (pathname?.startsWith('/pair/') && method === 'GET') {
    reloadState();
    const token = pathname.split('/pair/')[1];

    if (!serverState || serverState.pairingToken !== token) {
      return json(res, { error: 'Invalid token' }, 400);
    }

    return json(res, { serverPublicKey: serverState.publicKey });
  }

  // API: Pair POST - complete pairing (allows multiple devices)
  if (pathname?.startsWith('/pair/') && method === 'POST') {
    reloadState();
    const token = pathname.split('/pair/')[1];

    if (!serverState || serverState.pairingToken !== token) {
      return json(res, { error: 'Invalid token' }, 400);
    }

    let body = '';
    for await (const chunk of req) {
      body += chunk;
    }

    const { clientPublicKey } = JSON.parse(body);
    if (!clientPublicKey) {
      return json(res, { error: 'Missing clientPublicKey' }, 400);
    }

    const sharedSecret = deriveSharedSecret(serverState.privateKey, clientPublicKey);
    const newDevice: Device = {
      id: randomBytes(8).toString('hex'),
      publicKey: clientPublicKey,
      sharedSecret,
      createdAt: new Date().toISOString(),
    };

    addDevice(newDevice);
    devices = loadDevices();
    console.log(`> New device paired: ${newDevice.id} (total: ${devices.length})`);

    // Invalidate token after use (one-time use)
    serverState.pairingToken = null;
    saveServerState(serverState);
    console.log('> Pairing token invalidated (one-time use)');

    return json(res, { serverPublicKey: serverState.publicKey, deviceId: newDevice.id });
  }

  // API: Unpair specific device or all devices
  if (pathname === '/api/unpair' && method === 'POST') {
    let body = '';
    for await (const chunk of req) {
      body += chunk;
    }

    let deviceId: string | null = null;
    try {
      const parsed = JSON.parse(body);
      deviceId = parsed.deviceId || null;
    } catch {
      // No body or invalid JSON - unpair all
    }

    if (deviceId) {
      // Remove specific device
      removeDevice(deviceId);
      console.log(`> Device ${deviceId} unpaired`);
    } else {
      // Remove all devices
      const { writeFileSync } = await import('fs');
      const { join } = await import('path');
      const { homedir } = await import('os');
      const configDir = join(homedir(), '.config', 'claude-remote');
      writeFileSync(join(configDir, 'devices.json'), '[]');
      console.log('> All devices unpaired');
    }

    reloadState();
    return json(res, { success: true, deviceCount: devices.length });
  }

  // Static files (production)
  const distPath = join(process.cwd(), 'dist', 'client');
  if (existsSync(distPath)) {
    const requestedPath = pathname === '/' ? 'index.html' : (pathname || '').replace(/^\//, '');
    let filePath = resolve(distPath, requestedPath);

    // Path traversal protection: resolved path must be within distPath
    if (!filePath.startsWith(distPath + '/') && filePath !== distPath) {
      res.writeHead(403, { 'Content-Type': 'text/plain' });
      res.end('Forbidden');
      return;
    }

    // SPA fallback
    if (!existsSync(filePath) || !filePath.includes('.')) {
      filePath = join(distPath, 'index.html');
    }

    if (existsSync(filePath)) {
      const ext = filePath.split('.').pop() || '';
      const contentTypes: Record<string, string> = {
        html: 'text/html',
        js: 'application/javascript',
        css: 'text/css',
        json: 'application/json',
        png: 'image/png',
        svg: 'image/svg+xml',
      };

      res.writeHead(200, { 'Content-Type': contentTypes[ext] || 'text/plain' });
      res.end(readFileSync(filePath));
      return;
    }
  }

  // 404
  res.writeHead(404, { 'Content-Type': 'text/plain' });
  res.end('Not Found');
}

async function main() {
  pinHash = await hashPin(PIN!);
  initializeServer();
  recoverPartialResponses();

  const server = createServer(handleRequest);
  const wss = new WebSocketServer({ noServer: true });

  server.on('upgrade', (req, socket, head) => {
    const { pathname } = parse(req.url || '', true);

    if (pathname === '/ws') {
      wss.handleUpgrade(req, socket, head, (ws) => {
        wss.emit('connection', ws, req);
      });
    } else {
      socket.destroy();
    }
  });

  wss.on('connection', (ws: WebSocket, req: IncomingMessage) => {
    let authenticated = false;
    let currentDevice: Device | null = null;
    const clientIp = req.headers['x-forwarded-for']?.toString().split(',')[0]?.trim()
      || req.socket.remoteAddress || 'unknown';

    const sendEncrypted = (data: object) => {
      if (!currentDevice) return;
      if (ws.readyState !== WebSocket.OPEN) {
        // Write to disk for later
        appendEvent(currentDevice.id, data as ClaudeEvent);
        console.log(`[${currentDevice.id}] Event written to disk (ws not open)`);
        return;
      }
      const encrypted = encrypt(JSON.stringify(data), currentDevice.sharedSecret);
      ws.send(JSON.stringify(encrypted));
    };

    ws.on('message', async (raw: Buffer) => {
      reloadState();
      if (devices.length === 0) {
        ws.close(4001, 'No devices paired');
        return;
      }

      let encrypted: EncryptedData;
      try {
        encrypted = JSON.parse(raw.toString());
      } catch (err) {
        console.error('FATAL: Failed to parse WebSocket message as JSON:', err);
        console.error('Raw message:', raw.toString().substring(0, 200));
        ws.close(4002, 'Invalid JSON');
        return;
      }

      // Find device by trying decryption with each device's key
      if (!currentDevice) {
        currentDevice = findDeviceByDecryption(encrypted);
        if (currentDevice) {
          console.log(`Device identified: ${currentDevice.id}`);
        }
      }

      if (!currentDevice) {
        console.error('FATAL: No device could decrypt message - client needs to re-pair');
        ws.close(4003, 'Decryption failed - re-pair required');
        return;
      }

      let decrypted: string;
      try {
        decrypted = decrypt(encrypted, currentDevice.sharedSecret);
      } catch (err) {
        console.error('FATAL: Decryption failed - crypto keys mismatched. Client needs to re-pair.');
        console.error('Error:', err);
        ws.close(4003, 'Decryption failed - re-pair required');
        return;
      }

      let msg: { type: string; pin?: string; text?: string; projectId?: string };
      try {
        msg = JSON.parse(decrypted);
      } catch (err) {
        console.error('FATAL: Failed to parse decrypted message as JSON:', err);
        ws.close(4004, 'Invalid message format');
        return;
      }

      console.log(`[${currentDevice.id}] Received message type:`, msg.type);

      if (msg.type === 'auth') {
        if (!checkAuthRateLimit(clientIp)) {
          console.log(`Auth rate limited for IP: ${clientIp}`);
          sendEncrypted({ type: 'auth_error', error: 'Too many attempts. Try again later.' });
          return;
        }
        const valid = await verifyPin(msg.pin || '', pinHash);
        if (valid) {
          authenticated = true;
          console.log('Auth successful');
          
          // Register this connection
          connectedClients.set(currentDevice.id, ws);

          // Find all active jobs for this device (across all projects)
          const activeProjectIds: string[] = [];
          for (const key of activeJobs.keys()) {
            if (key.startsWith(`${currentDevice.id}:`)) {
              // Extract projectId from key format "deviceId:projectId"
              const projectId = key.substring(currentDevice.id.length + 1);
              activeProjectIds.push(projectId);
            } else if (key === currentDevice.id) {
              // Legacy global job (no projectId)
              activeProjectIds.push('__global__');
            }
          }

          sendEncrypted({ type: 'auth_ok', activeProjectIds });

          // Send partial responses for any active streaming sessions
          // This sends the accumulated content BEFORE pending events (which are deltas)
          if (activeProjectIds.length > 0) {
            const partials = loadPartialResponses();
            for (const projectId of activeProjectIds) {
              if (projectId === '__global__') continue;
              const jKey = jobKey(currentDevice.id, projectId);
              const partial = partials[jKey];
              if (partial) {
                sendEncrypted({
                  type: 'streaming_restore',
                  projectId,
                  thinking: partial.thinking,
                  text: partial.text,
                  activity: partial.activity,
                });
                console.log(`[${currentDevice.id}] Sent streaming restore for ${projectId}`);
              }
            }
          }

          // Flush any pending events from disk (but keep the file as backup)
          // These are delta events that occurred after the partial response was saved
          const pending = loadPendingEvents(currentDevice.id);
          if (pending.length > 0) {
            console.log(`[${currentDevice.id}] Flushing ${pending.length} pending events from disk`);
            for (const event of pending) {
              const encrypted = encrypt(JSON.stringify(event), currentDevice.sharedSecret);
              ws.send(JSON.stringify(encrypted));
            }
            // Don't clear - keep as backup log
          }
        } else {
          console.log('Auth failed - invalid PIN');
          sendEncrypted({ type: 'auth_error', error: 'Invalid PIN' });
        }
      } else if (msg.type === 'list_projects') {
        // List available projects
        const projects = listProjects();
        sendEncrypted({ type: 'projects_list', projects });
      } else if (msg.type === 'message') {
        if (!authenticated) {
          console.log('Message rejected - not authenticated');
          sendEncrypted({ type: 'error', error: 'Not authenticated' });
          return;
        }

        const userText = msg.text || '';
        const projectId = msg.projectId;
        console.log('Processing message:', userText.substring(0, 50), projectId ? `[project: ${projectId}]` : '[global]');

        // Validate projectId format and existence
        let projectPath: string | undefined;
        if (projectId) {
          if (!validateProjectId(projectId)) {
            sendEncrypted({ type: 'error', error: `Invalid project ID: ${projectId}`, projectId });
            return;
          }
          const project = getProject(projectId);
          if (!project) {
            sendEncrypted({ type: 'error', error: `Project not found: ${projectId}`, projectId });
            return;
          }
          projectPath = project.path;
        }

        // Save user message (to project or global)
        if (projectId) {
          addProjectMessage(projectId, {
            role: 'user',
            content: userText,
            timestamp: new Date().toISOString(),
          });
        } else {
          addMessage({
            role: 'user',
            content: userText,
            timestamp: new Date().toISOString(),
          });
        }

        // Broadcast user message + streaming start to other devices
        broadcastToOthers(currentDevice.id, {
          type: 'sync_user_message',
          projectId,
          text: userText,
        });

        const jKey = jobKey(currentDevice.id, projectId);
        const abortController = new AbortController();
        activeJobs.set(jKey, abortController);

        // Track assistant response
        let assistantThinking = '';
        let assistantText = '';
        const assistantActivity: ToolActivity[] = [];
        const assistantChunks: OutputChunk[] = [];
        let lastToolName: string | null = null;
        let currentChunkText = '';
        const taskStartedAt = new Date().toISOString();

        // Helper to detect if text starts a new chunk
        const isNewChunkStart = (text: string): boolean => {
          const trimmed = text.trim();
          // Text after a tool always starts a new chunk
          if (lastToolName !== null) return true;
          // Double newline indicates new section
          if (text.startsWith('\n\n')) return true;
          // Common transition phrases
          if (/^(Now|Next|Let me|I'll|First|Finally|Done|After|Moving|Continuing|Great|Perfect|Looking|Based on|The |This |I |Here)/i.test(trimmed)) return true;
          return false;
        };

        // Helper to flush current chunk
        const flushChunk = (afterTool?: string) => {
          if (currentChunkText.trim()) {
            assistantChunks.push({
              text: currentChunkText.trim(),
              timestamp: Date.now(),
              afterTool,
            });
            currentChunkText = '';
          }
        };

        // Get existing session ID for continuity
        const sessionId = projectId ? getProjectSessionId(projectId) : getClaudeSessionId();
        console.log('Using Claude session:', sessionId || 'new session', projectId ? `[project: ${projectId}]` : '');

        // On first resumed message after server boot, prepend context note
        const rejoinKey = projectId || '__global__';
        let messageToSend = userText;
        if (sessionId && !rejoinNoteSent.has(rejoinKey)) {
          rejoinNoteSent.add(rejoinKey);
          messageToSend = `[System: This is the first message from the user since the server rebooted.]\n\n${userText}`;
        }

        const deviceId = currentDevice.id;
        const deviceSecret = currentDevice.sharedSecret;

        spawnClaude(messageToSend, (event: ClaudeEvent) => {
          console.log('[ws] Claude event:', event.type, event.sessionId ? `sessionId=${event.sessionId}` : '', projectId ? `[project: ${projectId}]` : '');

          // Don't forward session_init to client, just save it
          if (event.type === 'session_init' && event.sessionId) {
            console.log('[ws] Saving session ID:', event.sessionId, projectId ? `[project: ${projectId}]` : '');
            if (projectId) {
              saveProjectSessionId(projectId, event.sessionId);
            } else {
              saveClaudeSessionId(event.sessionId);
            }
            return;
          }

          // Transform error events: Claude uses 'text', client expects 'error'
          let transformedEvent = event;
          if (event.type === 'error' && event.text && !('error' in event)) {
            transformedEvent = { ...event, error: event.text };
          }
          
          // Include projectId in all events sent to client
          const eventWithProject = projectId ? { ...transformedEvent, projectId } : transformedEvent;

          // Broadcast to ALL connected clients (not just the originating device)
          const eventJson = JSON.stringify(eventWithProject);
          let sentToAny = false;
          for (const [connDeviceId, connWs] of connectedClients.entries()) {
            if (connWs.readyState === WebSocket.OPEN) {
              const connDevice = devices.find(d => d.id === connDeviceId);
              if (connDevice) {
                const encrypted = encrypt(eventJson, connDevice.sharedSecret);
                connWs.send(JSON.stringify(encrypted));
                sentToAny = true;
              }
            }
          }
          if (!sentToAny) {
            // No clients connected â€” write to disk for the originating device
            appendEvent(deviceId, eventWithProject);
            console.log(`[${deviceId}] Event written to disk (no clients connected)`);
          }

          // Collect response for saving
          if (event.type === 'thinking' && event.text) {
            assistantThinking += event.text;
            savePartialResponse(jKey, assistantText, assistantThinking, assistantActivity);
          } else if (event.type === 'text' && event.text) {
            // Check if this text starts a new chunk
            if (isNewChunkStart(event.text) && currentChunkText.trim()) {
              flushChunk(lastToolName || undefined);
              lastToolName = null;
            }
            currentChunkText += event.text;
            assistantText += event.text;
            savePartialResponse(jKey, assistantText, assistantThinking, assistantActivity);
          } else if (event.type === 'tool_use' && event.toolUse) {
            // Flush any text before tool use
            flushChunk();
            lastToolName = event.toolUse.tool;
            assistantActivity.push({
              type: 'tool_use',
              tool: event.toolUse.tool,
              input: event.toolUse.input,
              timestamp: Date.now(),
            });
            savePartialResponse(jKey, assistantText, assistantThinking, assistantActivity);
          } else if (event.type === 'tool_result' && event.toolResult) {
            assistantActivity.push({
              type: 'tool_result',
              tool: event.toolResult.tool,
              output: event.toolResult.output,
              error: event.toolResult.error,
              timestamp: Date.now(),
            });
            savePartialResponse(jKey, assistantText, assistantThinking, assistantActivity);
          } else if (event.type === 'done') {
            // Flush any remaining chunk
            flushChunk(lastToolName || undefined);

            // Save assistant message when complete (to project or global)
            if (assistantText || assistantThinking || assistantActivity.length > 0) {
              const assistantMsg: Message = {
                role: 'assistant',
                content: assistantText,
                task: userText,  // Store the original user prompt
                chunks: assistantChunks.length > 0 ? assistantChunks : undefined,
                thinking: assistantThinking || undefined,
                activity: assistantActivity.length > 0 ? assistantActivity : undefined,
                startedAt: taskStartedAt,
                completedAt: new Date().toISOString(),
                timestamp: new Date().toISOString(),
              };
              if (projectId) {
                addProjectMessage(projectId, assistantMsg);
              } else {
                addMessage(assistantMsg);
              }
            }
            // Clear pending debounced writes and partial response file
            pendingPartials.delete(jKey);
            clearPartialResponse(jKey);
            // Clear active job
            activeJobs.delete(jKey);
            console.log(`[${deviceId}] Job complete for ${projectId || 'global'}, cleared from active jobs`);
          }
        }, abortController.signal, sessionId, projectPath);
      } else if (msg.type === 'cancel') {
        if (msg.projectId && !validateProjectId(msg.projectId)) {
          sendEncrypted({ type: 'error', error: 'Invalid project ID' });
          return;
        }
        console.log('Cancel requested', msg.projectId ? `[project: ${msg.projectId}]` : '[global]');
        const jKey = jobKey(currentDevice.id, msg.projectId);
        const abortController = activeJobs.get(jKey);
        if (abortController) {
          abortController.abort();
          activeJobs.delete(jKey);
        }
        // Notify other devices about the cancel
        broadcastToOthers(currentDevice.id, {
          type: 'sync_cancel',
          projectId: msg.projectId,
        });
      } else {
        console.log('Unknown message type:', msg.type);
      }
    });

    ws.on('close', () => {
      // Don't abort - let Claude keep running
      // Just remove from connected clients
      if (currentDevice) {
        connectedClients.delete(currentDevice.id);
        console.log(`[${currentDevice.id}] Client disconnected, Claude will continue running`);
      }
    });
  });

  server.listen(port, () => {
    console.log(`> Server ready on ${serverUrl}`);
    console.log(`> Client URL: ${clientUrl}`);
    console.log(`> Paired devices: ${devices.length}`);
    if (serverState.pairingToken) {
      const pairUrl = `${clientUrl}/pair?server=${encodeURIComponent(serverUrl)}&token=${serverState.pairingToken}`;
      console.log(`> Pair URL: ${pairUrl}`);
      console.log('');
      qrcode.generate(pairUrl, { small: true });
    }
  });
}

main();



#########################
### src/lib/claude.ts
import { spawn, ChildProcess } from 'child_process';

export interface ToolUseEvent {
  tool: string;
  input: Record<string, unknown>;
}

export interface ToolResultEvent {
  tool: string;
  output?: string;
  error?: string;
}

export interface ClaudeEvent {
  type: 'thinking' | 'text' | 'error' | 'done' | 'session_init' | 'tool_use' | 'tool_result';
  text?: string;
  sessionId?: string;
  toolUse?: ToolUseEvent;
  toolResult?: ToolResultEvent;
}

export function spawnClaude(
  message: string,
  onEvent: (event: ClaudeEvent) => void,
  signal?: AbortSignal,
  sessionId?: string | null,
  workingDirectory?: string
): ChildProcess {
  const args = ['--print', '--output-format', 'stream-json', '--verbose', '--dangerously-skip-permissions'];

  if (sessionId) {
    // Resume existing session
    args.push('--resume', sessionId, '-p', message);
    console.log('[claude] Resuming session:', sessionId);
  } else {
    // New session
    args.push('-p', message);
    console.log('[claude] Starting new session');
  }

  console.log('='.repeat(60));
  console.log('[claude] SPAWNING PROCESS');
  console.log('[claude] Command: claude', args.join(' '));
  console.log('[claude] Full args array:', JSON.stringify(args));
  console.log('[claude] Message:', message);
  console.log('[claude] Working directory:', workingDirectory || '(current)');
  console.log('='.repeat(60));

  const proc = spawn('claude', args, {
    stdio: ['ignore', 'pipe', 'pipe'],  // ignore stdin, pipe stdout/stderr
    cwd: workingDirectory,
  });

  console.log('[claude] Process spawned, PID:', proc.pid);

  if (!proc.pid) {
    const err = '[claude] FATAL: No PID - process failed to spawn!';
    console.error(err);
    throw new Error(err);
  }

  console.log('[claude] stdin ignored (not piped)');

  // TIMEOUT: If no output after 10 seconds, something is wrong
  let receivedOutput = false;
  const timeout = setTimeout(() => {
    if (!receivedOutput) {
      const err = `[claude] FATAL: No output received after 10 seconds! Process may be hung. PID: ${proc.pid}`;
      console.error(err);
      console.error('[claude] Killing hung process...');
      proc.kill('SIGKILL');
      onEvent({ type: 'error', text: err });
      onEvent({ type: 'done' });
    }
  }, 10000);

  const markOutputReceived = () => {
    if (!receivedOutput) {
      receivedOutput = true;
      clearTimeout(timeout);
      console.log('[claude] First output received, timeout cleared');
    }
  };

  let buffer = '';
  let sentAnyText = false;
  let sentDone = false;

  const processLine = (line: string) => {
    if (!line.trim()) return;

    console.log('[claude] Raw line:', line.substring(0, 150));

    let data;
    try {
      data = JSON.parse(line);
    } catch (err) {
      console.error('[claude] Failed to parse JSON line:', line.substring(0, 100), err);
      return;
    }

    console.log('[claude] Parsed event type:', data.type, data.subtype || '');

    // Handle the actual Claude CLI stream-json format
    if (data.type === 'system' && data.subtype === 'init') {
      const newSessionId = data.session_id;
      console.log('[claude] Session initialized, ID:', newSessionId);
      if (newSessionId) {
        onEvent({ type: 'session_init', sessionId: newSessionId });
      }
    } else if (data.type === 'assistant' && data.message) {
      // Extract content from the message
      const content = data.message.content;
      if (Array.isArray(content)) {
        for (const block of content) {
          if (block.type === 'thinking' && block.thinking) {
            console.log('[claude] Sending thinking');
            onEvent({ type: 'thinking', text: block.thinking });
          } else if (block.type === 'text' && block.text) {
            console.log('[claude] Sending text');
            onEvent({ type: 'text', text: block.text });
            sentAnyText = true;
          } else if (block.type === 'tool_use') {
            // Send full tool use event
            const toolName = block.name || 'unknown';
            const input = block.input || {};

            console.log('[claude] Tool use:', toolName);
            onEvent({
              type: 'tool_use',
              toolUse: {
                tool: toolName,
                input: input as Record<string, unknown>
              }
            });
          }
        }
      }
    } else if (data.type === 'user' && data.message) {
      // Tool results
      const content = data.message.content;
      if (Array.isArray(content)) {
        for (const block of content) {
          if (block.type === 'tool_result') {
            console.log('[claude] Tool result received');
            // Extract tool result content
            let output = '';
            if (typeof block.content === 'string') {
              output = block.content;
            } else if (Array.isArray(block.content)) {
              output = block.content
                .filter((c: { type: string }) => c.type === 'text')
                .map((c: { text: string }) => c.text)
                .join('\n');
            }

            onEvent({
              type: 'tool_result',
              toolResult: {
                tool: block.tool_use_id || 'unknown',
                output: output.substring(0, 5000), // Limit size
                error: block.is_error ? output : undefined
              }
            });
          }
        }
      }
    } else if (data.type === 'result') {
      console.log('[claude] Result received, sentAnyText:', sentAnyText, 'sentDone:', sentDone);
      // Only send result text if we haven't sent any text blocks yet
      // (avoids duplication for simple responses)
      if (!sentAnyText && data.result && typeof data.result === 'string') {
        console.log('[claude] Sending final result text (no prior text sent)');
        onEvent({ type: 'text', text: data.result });
      }
      if (!sentDone) {
        sentDone = true;
        onEvent({ type: 'done' });
      }
    }
  };

  proc.stdout?.on('data', (chunk: Buffer) => {
    markOutputReceived();
    const text = chunk.toString();
    console.log('[claude] STDOUT received, length:', text.length);
    console.log('[claude] STDOUT content:', text.substring(0, 200));
    buffer += text;
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';
    lines.forEach(processLine);
  });

  proc.stderr?.on('data', (chunk: Buffer) => {
    markOutputReceived();
    const text = chunk.toString();
    console.error('[claude] STDERR:', text);
    onEvent({ type: 'error', text });
  });

  proc.on('close', (code, signal) => {
    clearTimeout(timeout);
    console.log('[claude] CLOSED - code:', code, 'signal:', signal, 'sentDone:', sentDone);
    if (buffer.trim()) {
      processLine(buffer);
    }
    if (code !== 0 && code !== null) {
      const err = `[claude] FATAL: Process exited with code ${code}, signal: ${signal}`;
      console.error(err);
      onEvent({ type: 'error', text: err });
    }
    if (!sentDone) {
      sentDone = true;
      onEvent({ type: 'done' });
    }
  });

  proc.on('error', (err) => {
    clearTimeout(timeout);
    const msg = `[claude] FATAL PROCESS ERROR: ${err.message}`;
    console.error(msg, err);
    onEvent({ type: 'error', text: msg });
    onEvent({ type: 'done' });
  });

  proc.on('spawn', () => {
    console.log('[claude] SPAWN EVENT - process started successfully');
  });

  proc.on('disconnect', () => {
    console.log('[claude] DISCONNECT EVENT');
  });

  proc.on('exit', (code, signal) => {
    console.log('[claude] EXIT EVENT - code:', code, 'signal:', signal);
  });

  if (signal) {
    signal.addEventListener('abort', () => {
      proc.kill('SIGTERM');
    });
  }

  return proc;
}



#########################
### src/lib/crypto.ts
import { createECDH, createCipheriv, createDecipheriv, randomBytes, createHash } from 'crypto';

export interface EncryptedData {
  iv: string;
  ct: string;
  tag: string;
}

export interface KeyPair {
  privateKey: string;
  publicKey: string;
}

export function generateKeyPair(): KeyPair {
  const ecdh = createECDH('prime256v1');
  ecdh.generateKeys();
  return {
    privateKey: ecdh.getPrivateKey('base64'),
    publicKey: ecdh.getPublicKey('base64'),
  };
}

export function deriveSharedSecret(privateKey: string, peerPublicKey: string): string {
  const ecdh = createECDH('prime256v1');
  ecdh.setPrivateKey(Buffer.from(privateKey, 'base64'));
  const secret = ecdh.computeSecret(Buffer.from(peerPublicKey, 'base64'));
  // Hash with SHA-256 to ensure consistent 32-byte key across platforms
  const hashed = createHash('sha256').update(secret).digest();
  return hashed.toString('base64');
}

export function encrypt(plaintext: string, secret: string): EncryptedData {
  const key = Buffer.from(secret, 'base64'); // Already 32 bytes from SHA-256 hash
  const iv = randomBytes(12);
  const cipher = createCipheriv('aes-256-gcm', key, iv);

  const encrypted = Buffer.concat([
    cipher.update(plaintext, 'utf8'),
    cipher.final(),
  ]);

  return {
    iv: iv.toString('base64'),
    ct: encrypted.toString('base64'),
    tag: cipher.getAuthTag().toString('base64'),
  };
}

export function decrypt(data: EncryptedData, secret: string): string {
  const key = Buffer.from(secret, 'base64'); // Already 32 bytes from SHA-256 hash
  const iv = Buffer.from(data.iv, 'base64');
  const ct = Buffer.from(data.ct, 'base64');
  const tag = Buffer.from(data.tag, 'base64');

  const decipher = createDecipheriv('aes-256-gcm', key, iv);
  decipher.setAuthTag(tag);

  const decrypted = Buffer.concat([
    decipher.update(ct),
    decipher.final(),
  ]);

  return decrypted.toString('utf8');
}



#########################
### src/lib/store.ts
import { mkdirSync, readFileSync, writeFileSync, existsSync, readdirSync, statSync } from 'fs';
import { join, basename } from 'path';
import { homedir } from 'os';
import argon2 from 'argon2';

const CONFIG_DIR = join(homedir(), '.config', 'claude-remote');
const PROJECTS_DIR = join(CONFIG_DIR, 'projects');
const DEFAULT_PROJECTS_BASE = join(homedir(), 'projects');

export interface Device {
  id: string;
  publicKey: string;
  sharedSecret: string;
  createdAt: string;
}

export interface ServerState {
  privateKey: string;
  publicKey: string;
  pairingToken: string | null;
}

export interface Config {
  pinHash: string | null;
}

export interface ToolActivity {
  type: 'tool_use' | 'tool_result';
  tool: string;
  input?: Record<string, unknown>;
  output?: string;
  error?: string;
  timestamp: number;
}

export interface OutputChunk {
  text: string;
  timestamp: number;
  afterTool?: string;  // which tool triggered this chunk (if any)
}

export interface Message {
  role: 'user' | 'assistant';
  content: string;           // full text (for backwards compat and search)
  task?: string;             // user's original prompt (for assistant messages)
  chunks?: OutputChunk[];    // structured output chunks
  thinking?: string;
  activity?: ToolActivity[];
  startedAt?: string;        // when task started
  completedAt?: string;      // when task completed
  timestamp: string;         // legacy, use startedAt/completedAt
}

export interface Conversation {
  messages: Message[];
  claudeSessionId: string | null;
  updatedAt: string;
}

// Project-related interfaces
export interface Project {
  id: string;           // folder name e.g. "remote-claude-real"
  path: string;         // full path e.g. "/home/jamie/projects/remote-claude-real"
  name: string;         // display name (from package.json or folder)
  lastAccessed?: string;
}

export interface ProjectConversation {
  projectId: string;
  messages: Message[];
  claudeSessionId: string | null;
  updatedAt: string;
}

function ensureConfigDir() {
  if (!existsSync(CONFIG_DIR)) {
    mkdirSync(CONFIG_DIR, { recursive: true });
  }
}

export function loadDevices(): Device[] {
  try {
    const path = join(CONFIG_DIR, 'devices.json');
    if (!existsSync(path)) return [];
    return JSON.parse(readFileSync(path, 'utf8'));
  } catch {
    return [];
  }
}

export function saveDevices(devices: Device[]): void {
  ensureConfigDir();
  writeFileSync(join(CONFIG_DIR, 'devices.json'), JSON.stringify(devices, null, 2));
}

export function addDevice(device: Device): void {
  const devices = loadDevices();
  devices.push(device);
  saveDevices(devices);
}

export function removeDevice(deviceId: string): void {
  const devices = loadDevices();
  const filtered = devices.filter(d => d.id !== deviceId);
  saveDevices(filtered);
}

export function getDeviceById(deviceId: string): Device | null {
  const devices = loadDevices();
  return devices.find(d => d.id === deviceId) || null;
}

// Legacy single device support (deprecated)
export function loadDevice(): Device | null {
  try {
    const path = join(CONFIG_DIR, 'device.json');
    if (!existsSync(path)) return null;
    return JSON.parse(readFileSync(path, 'utf8'));
  } catch {
    return null;
  }
}

export function saveDevice(device: Device): void {
  ensureConfigDir();
  writeFileSync(join(CONFIG_DIR, 'device.json'), JSON.stringify(device, null, 2));
}

export function loadServerState(): ServerState | null {
  try {
    const path = join(CONFIG_DIR, 'server.json');
    if (!existsSync(path)) return null;
    return JSON.parse(readFileSync(path, 'utf8'));
  } catch {
    return null;
  }
}

export function saveServerState(state: ServerState): void {
  ensureConfigDir();
  writeFileSync(join(CONFIG_DIR, 'server.json'), JSON.stringify(state, null, 2));
}

export function loadConfig(): Config {
  try {
    const path = join(CONFIG_DIR, 'config.json');
    if (!existsSync(path)) return { pinHash: null };
    return JSON.parse(readFileSync(path, 'utf8'));
  } catch {
    return { pinHash: null };
  }
}

export function saveConfig(config: Config): void {
  ensureConfigDir();
  writeFileSync(join(CONFIG_DIR, 'config.json'), JSON.stringify(config, null, 2));
}

export async function hashPin(pin: string): Promise<string> {
  return argon2.hash(pin, {
    type: argon2.argon2id,
    memoryCost: 65536,
    timeCost: 3,
    parallelism: 1,
  });
}

export async function verifyPin(pin: string, hash: string): Promise<boolean> {
  try {
    return await argon2.verify(hash, pin);
  } catch {
    return false;
  }
}

export function loadConversation(): Conversation {
  try {
    const path = join(CONFIG_DIR, 'conversation.json');
    if (!existsSync(path)) return { messages: [], claudeSessionId: null, updatedAt: new Date().toISOString() };
    const data = JSON.parse(readFileSync(path, 'utf8'));
    // Ensure claudeSessionId exists for backwards compatibility
    if (!('claudeSessionId' in data)) {
      data.claudeSessionId = null;
    }
    return data;
  } catch (err) {
    console.error('[store] Failed to load conversation:', err);
    return { messages: [], claudeSessionId: null, updatedAt: new Date().toISOString() };
  }
}

export function saveClaudeSessionId(sessionId: string): void {
  const conversation = loadConversation();
  conversation.claudeSessionId = sessionId;
  saveConversation(conversation);
  console.log('[store] Claude session ID saved:', sessionId);
}

export function getClaudeSessionId(): string | null {
  const conversation = loadConversation();
  return conversation.claudeSessionId;
}

export function saveConversation(conversation: Conversation): void {
  ensureConfigDir();
  conversation.updatedAt = new Date().toISOString();
  writeFileSync(join(CONFIG_DIR, 'conversation.json'), JSON.stringify(conversation, null, 2));
  console.log('[store] Conversation saved, messages:', conversation.messages.length);
}

export function addMessage(message: Message): Conversation {
  const conversation = loadConversation();
  conversation.messages.push(message);
  saveConversation(conversation);
  return conversation;
}

export function clearConversation(): void {
  ensureConfigDir();
  const empty: Conversation = { messages: [], claudeSessionId: null, updatedAt: new Date().toISOString() };
  writeFileSync(join(CONFIG_DIR, 'conversation.json'), JSON.stringify(empty, null, 2));
  console.log('[store] Conversation and session cleared');
}

// ============================================
// Project-related functions
// ============================================

export function validateProjectId(projectId: string): boolean {
  if (!projectId) return false;
  // Reject path traversal attempts, slashes, backslashes, null bytes
  if (projectId.includes('..') || projectId.includes('/') || projectId.includes('\\') || projectId.includes('\0')) {
    return false;
  }
  return true;
}

function ensureProjectsDir() {
  if (!existsSync(PROJECTS_DIR)) {
    mkdirSync(PROJECTS_DIR, { recursive: true });
  }
}

function getProjectConfigDir(projectId: string): string {
  if (!validateProjectId(projectId)) {
    throw new Error(`Invalid project ID: ${projectId}`);
  }
  return join(PROJECTS_DIR, projectId);
}

function ensureProjectConfigDir(projectId: string): void {
  const dir = getProjectConfigDir(projectId);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }
}

// Check if a directory looks like a project
function hasProjectMarkers(dir: string): boolean {
  const markers = [
    'package.json',
    'Cargo.toml',
    'go.mod',
    'pyproject.toml',
    'setup.py',
    '.git',
    'Makefile',
    'CMakeLists.txt',
    'pom.xml',
    'build.gradle',
  ];
  return markers.some(marker => existsSync(join(dir, marker)));
}

// Get project name from package.json or folder name
function getProjectName(projectPath: string): string {
  try {
    const pkgPath = join(projectPath, 'package.json');
    if (existsSync(pkgPath)) {
      const pkg = JSON.parse(readFileSync(pkgPath, 'utf8'));
      if (pkg.name) return pkg.name;
    }
  } catch {
    // Ignore errors
  }

  try {
    const cargoPath = join(projectPath, 'Cargo.toml');
    if (existsSync(cargoPath)) {
      const content = readFileSync(cargoPath, 'utf8');
      const match = content.match(/name\s*=\s*"([^"]+)"/);
      if (match) return match[1];
    }
  } catch {
    // Ignore errors
  }

  return basename(projectPath);
}

// List all available projects from ~/projects
export function listProjects(basePath?: string): Project[] {
  const projectsBase = basePath || DEFAULT_PROJECTS_BASE;

  if (!existsSync(projectsBase)) {
    console.log('[store] Projects base path does not exist:', projectsBase);
    return [];
  }

  try {
    const dirs = readdirSync(projectsBase);
    const projects: Project[] = [];

    for (const dir of dirs) {
      if (dir.startsWith('.')) continue;

      const fullPath = join(projectsBase, dir);
      try {
        const stat = statSync(fullPath);
        if (!stat.isDirectory()) continue;

        if (hasProjectMarkers(fullPath)) {
          // Check if we have stored lastAccessed
          let lastAccessed: string | undefined;
          try {
            const convPath = join(getProjectConfigDir(dir), 'conversation.json');
            if (existsSync(convPath)) {
              const conv = JSON.parse(readFileSync(convPath, 'utf8'));
              lastAccessed = conv.updatedAt;
            }
          } catch {
            // Ignore
          }

          projects.push({
            id: dir,
            path: fullPath,
            name: getProjectName(fullPath),
            lastAccessed,
          });
        }
      } catch {
        // Skip directories we can't access
      }
    }

    // Sort by last accessed (most recent first), then by name
    return projects.sort((a, b) => {
      if (a.lastAccessed && b.lastAccessed) {
        return new Date(b.lastAccessed).getTime() - new Date(a.lastAccessed).getTime();
      }
      if (a.lastAccessed) return -1;
      if (b.lastAccessed) return 1;
      return a.name.localeCompare(b.name);
    });
  } catch (err) {
    console.error('[store] Failed to list projects:', err);
    return [];
  }
}

// Load conversation for a specific project
export function loadProjectConversation(projectId: string): ProjectConversation {
  try {
    const convPath = join(getProjectConfigDir(projectId), 'conversation.json');
    if (!existsSync(convPath)) {
      return {
        projectId,
        messages: [],
        claudeSessionId: null,
        updatedAt: new Date().toISOString(),
      };
    }
    const data = JSON.parse(readFileSync(convPath, 'utf8'));
    // Ensure all fields exist
    return {
      projectId,
      messages: data.messages || [],
      claudeSessionId: data.claudeSessionId || null,
      updatedAt: data.updatedAt || new Date().toISOString(),
    };
  } catch (err) {
    console.error(`[store] Failed to load project conversation for ${projectId}:`, err);
    return {
      projectId,
      messages: [],
      claudeSessionId: null,
      updatedAt: new Date().toISOString(),
    };
  }
}

// Save conversation for a specific project
export function saveProjectConversation(projectId: string, conversation: ProjectConversation): void {
  ensureProjectsDir();
  ensureProjectConfigDir(projectId);
  conversation.updatedAt = new Date().toISOString();
  const convPath = join(getProjectConfigDir(projectId), 'conversation.json');
  writeFileSync(convPath, JSON.stringify(conversation, null, 2));
  console.log(`[store] Project ${projectId} conversation saved, messages:`, conversation.messages.length);
}

// Add message to a specific project
export function addProjectMessage(projectId: string, message: Message): ProjectConversation {
  const conversation = loadProjectConversation(projectId);
  conversation.messages.push(message);
  saveProjectConversation(projectId, conversation);
  return conversation;
}

// Get Claude session ID for a specific project
export function getProjectSessionId(projectId: string): string | null {
  const conversation = loadProjectConversation(projectId);
  return conversation.claudeSessionId;
}

// Save Claude session ID for a specific project
export function saveProjectSessionId(projectId: string, sessionId: string): void {
  const conversation = loadProjectConversation(projectId);
  conversation.claudeSessionId = sessionId;
  saveProjectConversation(projectId, conversation);
  console.log(`[store] Project ${projectId} session ID saved:`, sessionId);
}

// Clear conversation for a specific project
export function clearProjectConversation(projectId: string): void {
  ensureProjectsDir();
  ensureProjectConfigDir(projectId);
  const empty: ProjectConversation = {
    projectId,
    messages: [],
    claudeSessionId: null,
    updatedAt: new Date().toISOString(),
  };
  const convPath = join(getProjectConfigDir(projectId), 'conversation.json');
  writeFileSync(convPath, JSON.stringify(empty, null, 2));
  console.log(`[store] Project ${projectId} conversation and session cleared`);
}

// Get project by ID (validates it exists)
export function getProject(projectId: string, basePath?: string): Project | null {
  if (!validateProjectId(projectId)) return null;
  const projectsBase = basePath || DEFAULT_PROJECTS_BASE;
  const fullPath = join(projectsBase, projectId);

  if (!existsSync(fullPath)) return null;

  try {
    const stat = statSync(fullPath);
    if (!stat.isDirectory()) return null;

    return {
      id: projectId,
      path: fullPath,
      name: getProjectName(fullPath),
    };
  } catch {
    return null;
  }
}



#########################
### src/types/qrcode-terminal.d.ts
declare module 'qrcode-terminal' {
  const qrcode: {
    generate(text: string, options?: { small?: boolean }, callback?: (qr: string) => void): void;
  };
  export default qrcode;
}



#########################
### tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx"
  },
  "include": ["**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules", "dist"]
}



#########################
### vite.config.ts
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), '');

  return {
    plugins: [react(), tailwindcss()],
    server: {
      port: 5173,
      host: true,
      allowedHosts: ['ai.pond.audio'],
      proxy: {
        '/api': {
          target: 'http://localhost:6767',
        },
        '/ws': {
          target: 'ws://localhost:6767',
          ws: true,
        },
      },
    },
    build: {
      outDir: 'dist/client',
    },
  };
});


#########################
### Lines of Code:
     0  public/file.svg
     0  public/globe.svg
     0  public/next.svg
     0  public/vercel.svg
     0  public/window.svg
     5  pnpm-workspace.yaml
     6  src/types/qrcode-terminal.d.ts
     8  client/src/components/types.ts
    10  client/src/main.tsx
    16  index.html
    18  eslint.config.mjs
    18  tsconfig.json
    19  claude-remote.service
    28  vite.config.ts
    41  client/src/App.tsx
    46  package.json
    53  client/src/index.css
    64  client/src/components/ChatInput.tsx
    64  src/lib/crypto.ts
   106  README.md
   112  client/src/components/ProjectTabs.tsx
   148  CLAUDE.md
   168  client/src/components/ProjectPicker.tsx
   233  client/src/components/GitStatus.tsx
   245  src/lib/claude.ts
   342  client/src/pages/Home.tsx
   352  client/src/components/ToolStack.tsx
   353  client/src/components/StreamingResponse.tsx
   460  src/lib/store.ts
  1108  server.ts
  1317  client/src/pages/Chat.tsx
-----------------------------------
Total Lines of Code: 5340
